# TCP协议

[TOC]



TCP提供了一种*面向连接的(connection-oriented)，可靠的*字节流服务



## 术语

- ARQ(Automatic Repeat Request，自动重复请求)

- ACK(acknowledgment， 确认)

- RTT(round-trip-time estimation， 往返时间估计)



## 封装

![tcp_ip_wrap](res/tcp_ip_wrap.png)

*TCP头部紧跟着IP头部或IPv6扩展头部，经常是20字节长（不带TCP选项）。带选项的话，TCP头部可达60字节。常见选项包括最大段大小，时间戳，窗口缩放和选择性ACK*



## 头部

![tcp_head](res/tcp_head.png)

- `源端口` 与IP头部中的源地址组合成一个端点(endpoint)，用于唯一标识发送方。

- `目的端口` 与IP头部中的目的地址组合成一个端点(endpoint)，用于唯一标识接收方。

- `序列号` Sequence Number，标识TCP发送端到TCP接收端的数据流的一个字节，该字节代表着包含该序列号的报文段的数据中的第一个字节。

- `确认号` Acknowledgment Number，发送方期待接收的下一个序列号。

- `头部长度` 定义了头部的长度，长度单位为字（32bit）；TCP头部被限制为60字节，不带选项的TCP头部大小为20字节。

- `保留字段`

- `CWR` 缩小拥塞窗口，发送方用来降低它的发送速率

- `ECE` ECN回显，发送方收到了一个更早的拥塞通告

- `URG` 紧急，让`紧急指针`生效，很少使用

- `ACK` 确认，让`确认号字段`生效，建立连接后启用

- `PSH` 推送

- `RST` 重置连接 

- `SYN` 初始化同步序号

- `FIN` 发送数据结束

- `窗口大小` 用来通告窗口大小（单位：字节数，最大65535字节），实现流量控制

- `TCP校验和` 强制性的，由发送方进行计算和保存，由接收方验证。

- `紧急指针` Urgent Pointer，只有当`URG`字段被设置时生效；

- `选项`(变长)

  | 种类 | 长度 | 名称           | 描述与目的                       |
  | ---- | ---- | -------------- | -------------------------------- |
  | 0    | 1    | EOL            | 选项列表结束                     |
  | 1    | 1    | NOP            | 无操作（用于填充）               |
  | 2    | 4    | MSS            | 最大段大小                       |
  | 3    | 3    | WSOPT          | 窗口缩放因子（窗口左移量）       |
  | 4    | 2    | SACK-Permitted | 发送者支持SACK选项               |
  | 5    | 可变 | SACK           | SACK阻塞（接收到乱序数据）       |
  | 8    | 10   | TSOPT          | 时间戳选项                       |
  | 28   | 4    | UTO            | 用户超时（一段空闲时间后的终止） |
  | 29   | 可变 | TCP-AO         | 认证选项（使用多种算法）         |
  | 253  | 可变 | Experimental   | 保留供实验所用                   |
  | 254  | 可变 | Experimental   | 保留供实验所用                   |

### 4元组多路分解

TCP依靠4元组多路分解（demultiplex）获得报文段，包括以下：

- 目的IP地址
- 目的端口号
- 源IP地址
- 源端口号

这4元组共同构成了本地与外地节点的信息。



## 连接的建立与终止

![tcp_start_end](res/tcp_start_end.png)

*一个普通TCP连接的建立与终止。通常，由客户端负责发起一个三次握手过程。在该过程中，客户端与服务器利用SYN报文段交换彼此的初始序列号（包括客户端的初始序列号和服务器的初始序列号）。在通信双方都发送了一个FIN数据包并收到来自对方的相应的确认数据包后，该连接终止*

### 建立连接

1. 客户端发送一个SYN报文段（设置SYN字段），并指明想要连接的端口号和初始序列号ISN(c)；
2. 服务端发送SYN报文段，包含初始序列号ISN(s)，ACK = ISN(c)+1；
3. 发送ACK = ISN(s)+1 报文；

### 关闭连接

1. 客户端发送一个FIN报文段，包括：序列号（K），一个ACK段；用于确认对方最近一次发来的的数据（L）。
2. 服务端将ACK设置为K+1，以表明它已经成功接收到客户端发送的FIN报文段。
3. 服务端发送自己的FIN，序列号为L，以表明它以成功发送完数据。
4. 客户端发送一个ACK用于确认上一个FIN。

### 半关闭操作

![tcp_half_close](res/tcp_half_close.png)

*在TCP半关闭操作中，连接的一个方向被关闭，而另一个方向仍在传输数据直到它被关闭为止；（很少有应用程序使用这一特性）*

### 同时打开与关闭

![tcp_open_closea](res/tcp_open_closea.png)

*在同时打开中交换的报文段。与正常的连接建立过程相比，需要增加一个报文段。数据报的SYN位将置位直到接收到一个ACK数据包为止*

![tcp_open_closeb](res/tcp_open_closeb.png)

*在同时关闭中交换的报文段。与正常关闭相似，指示报文段的顺序是交叉的*



## 状态转移

![tcp_stat](res/tcp_stat.png)

### 半开状态

如果在未告知另一端的情况下通信的一端关闭或终止连接，那么就认为该条TCP连接处于`半开状态`。

### TIME_WAIT状态

TIME_WAIT状态也称为`2MSL等待状态`或`加倍等待`，TCP将会等待两倍于最大段生存期（Maximum Segment Lifetime, MSL）的时间；

TIME_WAIT状态有2个存在的理由:

- 可靠地实现TCP全双工连接的终止；
- 允许老的重复分节在网络中消逝；

影响2MSL等待状态的因素：

1. 当TCP执行一个主动关闭并发送最终的ACK时，连接必须处于TIME_WAIT状态并持续两倍于最大生存期的时间。这样就能让TCP重新发送最终的ACK以避免出现丢失的情况。重新发送最终的ACK并不是因为TCP重传了ACK（他们并不消耗序列号，也不会被TCP重传），而是因为通信另一方重传了它的FIN（它消耗一个序列号）。

2. 当TCP处于等待状态时，通信双方将该连接（客户端IP地址，客户端端口号，服务器IP地址，服务器端口号）定义为不可重新使用。

   只有当2MSL等待结束时，或一条新链接使用的初始序列号超过了连接之前的实例所使用的最高序列号时，或者允许使用时间戳选项来区分之前连接实例的报文段以避免混淆时，这条连接才能被再次使用。

有许多机制可以绕开2MSL限制，如：`SO_REUSEADDR`套接字选项...

**静默时间**，[RFC0793]指出，在崩溃或者重启后TCP协议应当在创建新的连接之前等待相当于一个MSL的时间，该段时间被称为*静默时间*。

TIME_WAIT过多怎么处理？

### FIN_WAIT_2状态

在FIN_WAIT_2状态，某TCP通信端已发送一个FIN并已得到另一端的确认，除非出现半关闭的情况，否则该TCP端将会等待另一端的应用程序识别出自己已接收到一个文件末尾的通知并关闭这一端引起发送FIN的连接。只有当应用程序完成了这一关闭操作（它的FIN已经被接收），正在关闭的TCP连接才会从FIN_WAIT_2状态转移至TIME_WAIT状态。这意味着连接的一端能够依然永远保持这种状态。另一端也会依然处于CLOSE_WAIT状态，并且能永远维持这一状态直到应用程序决定宣布他的关闭。



## 分组窗口

TODO



## 滑动窗口

`滑动窗口协议（sliding window protocol）`示意：

![tcp_sliding_window](res/tcp_sliding_window.png)

*发送方窗口，显示了哪些分组将要被发送（或已经发送），哪些尚未发送，以及哪些已经发送并确认。在这个例子里，窗口大小被确定为三个分组*



## 流量控制

流量控制（flow control）：在接收方跟不上时会强迫发送方慢下来，一共有2种方法：

- 基于速率（rate-based）流量控制

  给发送方指定某个速率，同时确保数据永远不能超过这个速率发送，适用于流应用程序。

- 基于窗口（windows-based）流量控制

  使用滑动窗口，窗口大小不是固定的，而是允许随时间而变动的；发送方使用**窗口通告(window advertisement)或窗口更新(window update)**调整窗口大小。

  

## 拥塞控制

### Nagle算法

`Nagle算法` 当一个TCP连接中有在传数据（即那些已发送但还未经确认的数据），小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK。并且，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。此算法迫使TCP遵循停等（stop-and-wait）规程--只有等接收到所有在传数据的ACK后才能继续发送。此算法的精妙之处在于它实现了自时钟（self-clocking）控制：ACK返回越快，数据传输也越快。在相对高延迟的广域网中，更需要减少微型报的数目，该算法使得单位时间内发送的报文段数目更少。也就是说，RTT控制着发包速率。



## 超时重传

### RTT测量

#### 经典方法

最初的TCP规范[RFC0793]采用如下公式计算得到`平滑的RTT估计值（俗称SRTT）`：

$SRTT \leftarrow a(SRTT) + (1 - a)RTT_s$

- $a$ 平滑因子（常量，推荐0.8~0.9）

这种估算方法称为`指数加权移动平均(Exponentially Weighted Moving Average, EWMA)`或`低通过滤器(low-pass filter)`；

考虑到SRTT估计器得到的估计值会随RTT而变化，[RFC0793]推荐根据如下公式设置RTO：

$RTO=min(ubound, max(lbound, (SRTT)\beta))$

- $\beta$ 时延离散因子（推荐1.3~2.0）
- $ubound$ RTO的上边界（可设定建议值，1min）
- $lbound$ RTO的下边界（可设定建议值，1sec）

#### 标准方法

经典方法的缺陷：

- 按照经典方法设置计时器无法适应RTT的大规模变动，当实际的RTT远大于估计值时，会导致不必要的重传；
- 增大的RTT样本值表明网络已出现过载，此时不必要的重传会进一步加重网络负担；

标准方法在采用经典方法的同时，考虑RTT变化值以及均值来设置RTO，比仅使用均值的常数倍来计算RTO更能适应RTT变化幅度较大的情况；

对每个RTT测量值$M$(即前面的$RTT_s$)采用以下方法估算：

$srtt \leftarrow (1-g)(srtt)+(g)M$

$rttvar \leftarrow (1-h)(rttvar) + (h)(|M-srtt|)$

$RTO = srtt + 4(rttvar)$

或另一种对计算机实现来说操作较为方便的估算方法：

$Err = M - srtt$

$srtt \leftarrow srtt + g(Err)$

$rttvar \leftarrow rttvar + h(|Err| - rttvar)$

- $srtt$ 均值的EWMA
- $rttvar$ 绝对误差$|Err|$的EWMA
- $Err$ 测量值M与当前RTT估计值srtt估计值的权重
- $h$ 为新平均偏差样本（新样本M与当前平均值srtt之间的绝对误差）占偏差估计值$rttvar$的权重（取1/4）；

当$RTT$变化时，偏差的增量越大，$RTO$增长越快；$g$和$h$的值取为2的（负的）多少次方，使得整个计算过程较为简单，对计算机来说只要采用定点整型数的移位和加法操作即可，而无需复杂的乘除法运算；

### 基于计时器的重传

若在连接设定的RTO内，TCP没有收到被计时报文段的ACK，将会触发超时重传；TCP通过降低当前数据发送率来响应超时重传，它的实现有2种方法：

- 基于拥塞控制机制减少发送窗口大小；

- 为每当一个重传报文段被再次重传时，增大RTO的退避因子；当同一报文段出现多次重传时，RTO值乘上值$\gamma$来形成新的超时退避值：

  $RTO = \gamma RTO$

  - $\gamma$ 值为1，随着多次重传，$\gamma$呈加倍增长（2, 4, 8, ...），不能超过最大退避因子（Linux确保其RTO设置不能超过`TCP_RTO_MAX`，默认值为120s），一旦接收到相应的ACK，$\gamma$重置为1；

#### 示例

![tcp_rtns](res/tcp_rtns.png)

报文段1401被人为地丢弃2次，导致发送端引发了超时重传；仅在接收到使得发送窗口前移的ACK时，srtt, rttvar和RTO值才会做出更新；带星号`（*）`的ACK包含了SACK信息；

### 快速重传

`快速重传算法`：TCP发送端在观测到至少`dupthresh`个重复ACK后，即重传可能丢失的数据分组，而不必等到重传计时器超时；当然也可以同时发送新的数据，根据重复ACK推断的丢包与网络拥塞有关，因此伴随快速重传应出发拥塞控制机制；不采用SACK时，在接收到有效ACk前至多只能重传一个报文段；采用SACK，ACK可包含额外信息，使得发送端在每个RTT时间内可以填补多个空缺；

### 带选择确认的重传

TODO

### 伪超时与重传

TODO



## 包失序与包重复

### 失序

TODO



## 安全

### 初始序列号攻击

1. TCP报文段伪造；

   选择合适的序列号，IP地址以及端口号，那么任何人都能伪造出一个TCP报文段，从而打断TCP的正常连接`[RFC5961]`。

   Linux系统采用基于时钟的方案，并且针对每一个连接为时钟设置随机的偏移量，来设置初始序列号，从而防止TCP报文段被伪造。具体参考：`CA-2001-09[CERTISN]`。

### 时间等待错误

`时间等待错误（TIME-WAIT Assassination, TWA）` 如果在`TIME_WAIT`状态下接收到来自于这条连接的一些报文段，或是更加特殊的重置报文段，它将会被破坏；

![tcp_time_wait_err](res/tcp_time_wait_err.png)

### 重传攻击

1. 低速率DoS攻击

   攻击者向网关或主机发送大量数据，使得受害系统持续处于重传超时状态。由于攻击者可预知受害TCP合适启动重传，并在每次重传时生成并发送大量数据。因此，受害TCP总能感知到拥塞的存在，根据Karn算法不断减小发送速率并退避发送，导致无法正常使用网络带宽。针对此类攻击的预防方法是随机选择RTO，使得攻击者无法预知确切的重传时间。

2. 减慢/加速TCP的发送

   使RTT估值过大，这样受害者在丢包后不会立即重传。相反的攻击也是有可能的：攻击者在数据发送完成但还未到达接收端伪造ACK。这样攻击者就能使受害TCP认为连接的RTT远小于实际值，导致过分发送，造成大量的无效传输。



## 参考

[1] [美] Kevin R. Fall, [美] W. Richard Stevens.Tcp/ip详解.3ED

