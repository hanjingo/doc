# 面试笔记



## 算法



## 系统

1. 简述进程，线程和协程以及它们的区别

   - 进程

     是系统进行资源分配和调度的一个独立单位，每个进程都有自己独立的内存空间，不同进程通过进程间通信来交流。比较heavy，上下文切换开销大，但是比线程稳定。

   - 线程

     是进程的一个实体，是cpu调度和分派的基本单位；比进程轻，不拥有系统资源，只拥有一些必要的运行时资源（如程序计数器，寄存器和栈）；拥有函数的入口和返回，可以与同一个进程内的其他线程共享进程的所有资源；线程间通信主要通过共享内存，上下文切换开销小，但是不够稳定。

   - 协程

     **是一种用户态的轻量级线程**，调度完全由用户控制。拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来时，恢复前面的寄存器上下文和栈；上下文切换基本没有开销。

   区别：

   - 进程-线程
     1. 调度：**线程作为调度和分配的基本单位，真正在处理机上运行的是线程，进程作为拥有资源的基本单位**
     2. 资源：进程是资源分配和拥有的单位，同一个进程中的所有线程共享进程资源
     3. 开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致进程切换开销大，线程切换开销小
     4. 并发：进程之间运行互不影响，线程共享进程的系统资源，健壮性差

   - 线程-协程
     1. 开销：协程能保留上一次调用时的状态，每次过程重入都会恢复上一次的状态，协程的开销非常小。
     2. 并发：线程都是同步机制，协程都是异步机制，在协程中控制共享资源不需要加锁

2. epoll详解

3. linux内存管理机制

4. 文件系统

5. 程序的结构

6. 堆和栈的区别



## 工具

### skynet

1. 定时器
2. actor模型
3. 集群
4. lua虚拟机
5. 负载均衡
6. 热更

## redis

1. 数据模型
2. 同步机制
3. 跳表的用途与缺陷



## 项目

1. 游戏服务器的架构是怎样的
2. 热更新的用途
   1. 上线需求（审核）
   2. 快节奏的版本迭代
   3. 节约网络资源
3. protobuf的底层实现
4. 使用UDP的理由
   1. 低延迟



## c++

1. 描述下c++中四种`cast`以及他们的使用场景

   - `static_cast`-静态转换

     用于各种隐式转化；在编译期间处理，无运行时类型检查来保证安全性。

     用于以下转换：

     - 基类与子类的指针或引用的上行转换(安全)和下行转换(不安全)
     - 基本数据类型之间的转换
     - 空指针转换为目标类型的空指针
     - 任何类型的表达式转化成void类型

   - `dynamic_cast`-动态转换

     只能用于含有虚函数的类；在运行期处理，带类型检查。

     用于以下转换：

     - 基类与子类的指针或引用的上行转换(安全)和下行转换(安全，带类型检查功能)
     - 交叉转换(`B:A, D:A; dynamic_cast<D>(B)`)

   - `reinterpret_cast`

     用于以下转换：

     - 指针与整数之间的转换

   - `const_cast`

     修改`const`和`volatile`属性

     用于以下转换：

     - 常量指针转非常量指针
     - 常量引用转非常量引用

2. 为什么要用`virtual destructor`？为什么没有`virtual constructor`?

   - 防止内存泄漏

3. 哪些函数不能是虚函数？

4. 指针和引用的用途和区别

5. memcpy怎么实现让它效率更高

6. malloc/free，new/delete的原理和区别



## lua

1. lua数据类型

   - number
   - string
   - boolean
   - function
   - table
   - userdata
   - thread
   - nil

   

