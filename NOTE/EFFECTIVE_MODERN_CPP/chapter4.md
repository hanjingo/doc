# 第四章 智能指针
裸指针的缺点:

1. 裸指针的声明中并没有指出，裸指针指涉到的是单个对象还是一个数组。
2. 裸指针在声明中也没有提示在使用完指涉的对象以后，是否需要析构它。换言之，你从声明中看不出来指针是否拥有其指涉的对象。
3. 即使知道需要析构指针所指涉的对象，也不可能知道如何析构才是适当的。是应该使用delete运算符呢，还是别有它途。
4. 即使知道了应该使用delete运算符，参见理由1，还是会发生到底应该用单个对象形式("delete")还是数组形式("delete[]")的疑问。一旦用错，就会导致未定义的行为。
5. 即启用够确信，指针拥有其指涉的对象，并且也确知应该如何析构，要保证析构在所有代码路径上都仅执行一次（包括那些异常的路径）仍然困难重重。只要少在一条路径上执行，就会导致资源泄漏。而如果析构在一条路径上执行了多于一次，则会导致未定义的行为。
6. 没有什么正规的方式能检测出指针是否空悬(dangle),也就是说，它指涉的内存是否已经不再持有指针本应该指涉的对象。如果一个对象已经被析构了，而某些指针仍然指涉到它，就会产生空悬指针。

# 条款18: 使用std::unique_ptr管理具备专属所有权的资源
* std::unique_ptr是小巧，高速的，具备只移型别的智能指针，对托管资源实施专属所有权语义。
* 默认地，资源析构采用delete运算符来实现，但可以指定自定义删除器。有状态的删除器和采用函数指针实现的删除器会增加std::unique_ptr型别的对象尺寸。
* 将std::unique_ptr转换成std::shared_ptr是容易实现的。

# 条款19: 使用std::shared_ptr管理具备共享所有权的资源
引用计数:
* std::share_ptr的尺寸是裸指针的2倍。
* 引用计数的内存必须动态分配。
* 引用计数的递增和递减必须是原子操作。

控制块的创建组训了以下规则:
* std::make_shared总是创建一个控制块。
* 从具备专属所有权的指针(即std::unique_ptr或std::auto_ptr指针) 出发构造一个std::shared_ptr时，会创建一个控制块。
* 当std::shared_ptr构造函数使用裸指针作为实参来调用时，他会创建一个控制块。

* std::shared_ptr 提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。
* 与std::unique_ptr 相比, std::shared_ptr的尺寸通常是裸指针尺寸的2倍，它还会带来控制块的开销，并要求原子化的引用计数操作。
* 默认的资源析构通过delete运算符进行，但同时也支持定制删除器。删除器的型别对std::shared_ptr的型别没有影响。
* 避免使用裸指针型别的变量来创建std::shared_ptr指针。