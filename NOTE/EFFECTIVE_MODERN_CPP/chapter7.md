# 第七章 并发API
## 条款35: 优先选用基于任务而非基于线程的程序设计
- std::thread的API未提供直接获取异步运行函数返回值的途径，而且如果那些函数抛出异常，程序就会终止。
- 基于线程的程序设计要求手动管理线程耗尽，超订，负载均衡，以及新平台适配。
- 经由应用了默认启动策略的std::async进行基于任务的程序设计，大部分这类问题都能找到解决之道。

## 条款36: 如果异步是必要的，则指定std::launch::async
- std::launch::async 启动策略意味着函数f必须以异步方式运行，亦即，在另一线程之上执行。
- std::launch::deferred 启动策略意味着函数f只会在std::async所返回的期值的get或wait得到调用时才运行。
- std::async 的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行。
- 如此的弹性会导致使用thread_local变量时的不确定性，隐含着任务可能永远不会执行，还会影响运用了基于超时的wait调用的程序逻辑。
- 如果异步是必要的，则指定std::launch::async。

## 条款37: 使std::thread型别对象在所有路径皆不可联结
- 使std::thread型别对象在所有路径皆不可联结
- 在析构时调用join可能导致难以调试的性能异常
- 在析构时调用detach可能导致难以调试的未定义行为
- 在成员列表的最后声明std::thread型别对象

## 条款38：对变化多端的线程句柄析构函数行为保持关注
- 期值的析构函数在常规情况下，仅会析构期值的成员变量
- 指涉到经由std::async启动的未推迟任务的共享状态的最后一个期值会保持阻塞，直至该任务结束

## 条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值
- 如果仅为了实现平凡事件通信，基于条件变量的设计会要求多余的互斥量，这会给相互关联的检测和反应任务带来约束，并要求反应任务校验事件确已发生
- 使用标志位的设计可以避免上述问题，但这一设计基于轮询而非阻塞
- 条件变量和标志位可以一起使用，但这样的通信机制设计结果不甚自然
- 使用std::promise型别对象和期值就可以回避这些问题，但是一来这个途径为了共享状态需要使用堆内存，而且仅限于一次性通信

## 条款40：对并发使用std::atomic,对特种内存使用volatile
- std::atomic用于多线程访问的数据，且不用互斥量。他是撰写并发软件的工具。
- volatile用于读写操作不可以被优化掉的内存。它是在面对特种内存时使用的工具。



