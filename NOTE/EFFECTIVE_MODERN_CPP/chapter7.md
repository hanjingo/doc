# 第七章 并发API
## 条款35: 优先选用基于任务而非基于线程的程序设计
- std::thread的API未提供直接获取异步运行函数返回值的途径，而且如果那些函数抛出异常，程序就会终止。
- 基于线程的程序设计要求手动管理线程耗尽，超订，负载均衡，以及新平台适配。
- 经由应用了默认启动策略的std::async进行基于任务的程序设计，大部分这类问题都能找到解决之道。

## 条款36: 如果异步是必要的，则指定std::launch::async
- std::launch::async 启动策略意味着函数f必须以异步方式运行，亦即，在另一线程之上执行。
- std::launch::deferred 启动策略意味着函数f只会在std::async所返回的期值的get或wait得到调用时才运行。
- std::async 的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行。
- 如此的弹性会导致使用thread_local变量时的不确定性，隐含着任务可能永远不会执行，还会影响运用了基于超时的wait调用的程序逻辑。
- 如果异步是必要的，则指定std::launch::async。

## 条款37: 使std::thread型别对象在所有路径皆不可联结
- 默认构造的std::thread. 此类std::thread没有可以执行的函数，因此也没有对应的底层执行线程。
- 已移动的std::thread. 移动操作的结果是，一个std::thread所对应的底层执行
