# 第三章 转向现代c++
## 条款7:在创建对象时注意区分()和{}
* 大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫。
* 在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。
* 使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个std::vector<数值型别>对象。
* 在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。

## 条款8:优先选用nullptr，而非0或NULL
* 相对于0或NULL,优先选用nullptr。
* 避免在整型和指针型别之间重载。

## 条款9:优先选用别名声明，而非typedef
* typedef不支持模板化，但别名声明支持。
* 别名模板可以让人免写"::type"后缀，并且在模板内，对于内嵌typedef的引用经常要求加上typename前缀。

## 条款10:优先选用限定作用域的枚举型别，而非不限作用域的枚举型别
* c++98风格的枚举型别，现在称为不限范围的枚举型别。
* 限定作用域的枚举型别仅在枚举型别内可见。他们只能通过强制型别转换以转换至其他型别。
* 限定作用域的枚举型别和不限定范围的枚举型别都支持底层型别指定。限定作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别。
* 限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才可以进行前置声明。

## 条款11:优先选用删除函数，而非private未定义函数
* 优先选用删除函数，而非private未定义函数。
* 任何函数都可以删除，包括非成员函数和模板具现。

## 条款12:为意在改写的函数添加override声明
* 为意在改写的函数添加override声明。
* 成员函数引用饰词使得对于左值和右值对象(*this)的处理能够区分开来。