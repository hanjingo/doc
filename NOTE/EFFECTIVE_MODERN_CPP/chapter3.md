# 第三章 转向现代c++
## 条款7:在创建对象时注意区分()和{}
* 大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫。
* 在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。
* 使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个std::vector<数值型别>对象。
* 在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。

## 条款8:优先选用nullptr，而非0或NULL
* 相对于0或NULL,优先选用nullptr。
* 避免在整型和指针型别之间重载。

## 条款9:优先选用别名声明，而非typedef
* typedef不支持模板化，但别名声明支持。
* 别名模板可以让人免写"::type"后缀，并且在模板内，对于内嵌typedef的引用经常要求加上typename前缀。

## 条款10:优先选用限定作用域的枚举型别，而非不限作用域的枚举型别
* c++98风格的枚举型别，现在称为不限范围的枚举型别。
* 限定作用域的枚举型别仅在枚举型别内可见。他们只能通过强制型别转换以转换至其他型别。
* 限定作用域的枚举型别和不限定范围的枚举型别都支持底层型别指定。限定作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别。
* 限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才可以进行前置声明。

## 条款11:优先选用删除函数，而非private未定义函数
* 优先选用删除函数，而非private未定义函数。
* 任何函数都可以删除，包括非成员函数和模板具现。

## 条款12:为意在改写的函数添加override声明
* 为意在改写的函数添加override声明。
* 成员函数引用饰词使得对于左值和右值对象(*this)的处理能够区分开来。

## 条款13:优先选用const_iterator,而非iterator
* 优先选用const_iterator,而非iterator。
* 在最通用的代码中,优先选用非成员函数版本的begin,end和rebegin等,而非其成员函数版本。

## 条款14:只要函数不会发射异常，就为其加上noexcept声明
* noexcept声明是函数接口的组成部分，这意味着调用方可能会对它有依赖。
* 相对于不带noexcept声明的函数，带有noexcept声明的函数有更多机会得到优化。
* noexcept性质对于移动操作,swap,内存释放函数和析构函数最有价值。
* 大多数函数都是异常中立的，不具备noexcept性质。

## 条款15:只要有可能使用constexpr,就使用它
* constexpr对象都具备const属性，并由编译期已知的值完成初始化。
* constexpr函数在调用时若传入的实参值是编译期已知的，则会产出编译期结果。
* 比起非constexpr对象或constexpr函数而言，constexpr对象或是constexpr函数可以用在一个作用域更广的语境中。

## 条款16:保证const成员函数的线程安全性
* 保证const成员函数的线程安全性，除非可以确信它们不会用在并发语境中。
* 运用std::atomic 型别的变量会比运用互斥量提供更好的性能，但前者仅适用对单个变量或内存区域的操作。

c++11中，支持特种成员函数的机制如下:
* 默认构造函数: 与c++98的机制相同。仅当类中不包含用户声明的构造函数时才生成。
* 析构函数: 与c++98的机制基本相同，唯一的区别在于析构函数默认为noexcept。与c++98的机制相同，仅当积累的析构函数为虚的，派生类的析构函数才是虚的。
* 复制构造函数: 运行期行为与c++98相同：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为。
* 复制赋值运算符: 运行期行为与c++98相同: 按成员进行非静态数据成员的复制赋值。仅当类中不包含用户声明的复制赋值运算符时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制构造函数或析构函数的条件下，仍然生成复制赋值运算符已经成为了被废弃的行为。
* 移动构造函数和移动赋值运算符: 都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作，移动操作和析构函数时才生成。
