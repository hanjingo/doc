# 第五章 右值引用，移动语义和完美转发
- **移动语义**使得编译器第一使用不那么昂贵的移动操作，来替换昂贵的复制操作。
- 完美转发使得人们可以撰写接收任意实参的函数模板，并将其转发到其他函数，目标函数会接收到与转发函数所接受的完全相同的实参。

## 条款23: 理解std::move和std::forward
- std::move实施的是无条件的向右值型别的强制型别转换。就其本身而言，它不会执行移动操作。
- 仅当传入的实参被绑定到右值时，std::forward才针对该实参实施向右值型别的强制型别转换。
- 在运行期，std::move和std::forward都不会做任何操作.

## 条款24: 区分万能引用和右值引用
- 如果函数模板形参具备T&&型别，并且T的型别系推导而来，或如果对象使用auto&&声明型别，则该形参或对象就是个万能引用。
- 如果型别声明并不精确的具备type&&的形式，或者型别推导并未发生，则type&&就代表右值引用。
- 若采用右值来初始化万能引用，就会得到一个右值引用。若采用左值来初始化万能引用，就会得到一个左值引用。

## 条款25: 针对右值引用实施std::move,针对万能引用实施std::forward
- 针对右值引用的最后一次使用实施std::move,针对万能引用的最后一次使用实施std::forward。
- 作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行为。
- 若局部对象可能适用于返回值优化，则请勿针对其实施std::move或std::forward。

## 条款26: 避免依万能引用型别进行重载
- 把万能引用作为重载候选型别，几乎总会让该重载版本在始料未及的情况下被调用到。
- 完美转发构造函数的问题尤其严重，因为对于非常量的左值型别而言，他们一般都会形成对于复制构造函数的更佳匹配，并且他们还会劫持派生类中对基类的复制和移动构造函数的更佳匹配，并且他们还会劫持派生类中对基类的复制和移动构造函数的调用。

## 条款27: 熟悉依万能引用型别进行重载的替代方案
- 如果不能使用万能引用和重载的组合，则替代方案包括使用彼此不同的函数名字，传递const T&型别的形参，传值和标签分派。
- 经由std::enable_if对模板施加限制，就可以将万能引用和重载一起使用，不过这种技术控制了编译器可以调用到接受万能引用的重载版本的条件。
- 万能引用形参通常在性能方面具备优势，但在易用性方面一般会有劣势。

## 条款28: 理解引用折叠
- 引用折叠会在四种语境中发生:模板实例化，auto型别生成，创建和运用typedef和别名声明，以及decltype。
- 当编译器在引用折叠的语境下生成引用的引用时，结果会变成单个引用。如果原始的引用中有任一引用为左值引用，则结果为左值引用。否则，结果为右值引用。
- 万能引用就是在型别推导的过程会区别左值和右值，以及会发生引用折叠的语境中的右值引用。

## 条款29: 假定移动操作不存在，成本高，未使用
- 假定移动操作不存在，成本高，未使用。
- 对于那些型别或对于移动语义的支持情况已知的代码，则无需做以上假定。

## 条款30: 熟悉完美转发的失败情形
- 完美转发的失败情形，是源于模板型别推到失败或推导结果是错误的型别。
- 会导致完美转发失败的实参种类有大括号初始化物，以值0或NULL表达的空指针，仅有声明的整形static const成员变量，模板或重载的函数名字，以及位域。

