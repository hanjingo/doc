# 第二章 算法基础



## 2.1 插入排序

输入：$n$个数$(a_1, a_2, ..., a_n)$。

输出：输入序列的一个排列（即重新排序）$(a_1', a_2', ..., a_n')$，使得$a_1' \leqslant a_2' \leqslant ... \leqslant a_n'$。

```c++
INSERTION-SORT(A)
for j = 2 to A.length
    key = A[j]
    // Insert A[j] into the sorted sequence A[1..j-1].
    i = j - 1
    while i > 0 and A[i] > key
        A[i + 1] = A[i]
        i = i - 1
    A[i + 1] = key
```

![2_2](res/2_2.png)

循环不变式主要用于帮助我们理解算法的正确性，其具有一下三条性质：

- `初始化:` 循环的第一次迭代之前，它为真。
- `保持:` 如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。
- `终止:` 在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的




## 2.2 分析算法

`算法分析` 即指对一个算法所需要的资源进行预测。

**术语**

`运行时间` 执行的基本操作数或步数。

`输入规模`

**INSERTION-SORT算法分析**

计算在具有$n$个值的输入上INSERTION-SORT的运行时间$T[n]$，我们将代价与次数列对应元素之积求和，得到：$T(n) = C_1n + c_2(n - 1) + c_4(n - 1) + C_5\sum_{j=2}^{n}t_j + c_6\sum_{j=2}^{n}(t_j - 1) + c_7\sum_{j=2}^{n}(t_j - 1) + C_8(n - 1)$

- 最佳情况：输入数组已经提前正向排序。这时，对每个$j=2, 3, ..., n$，我们发现在第5行，当$i$取其初值$j - 1$时，有$A[i] \leqslant key$。从而对$j = 2, 3, ..., n$有$t_j = 1$，该最佳情况的运行时间为：
  $$
  \begin{equation}\begin{split} 
  T(n) &= C_1n + c_2(n-1) + C_4(n-1) + c_5(n-1) + c_8(n-1) \\
  &= (c_1 + c_2 + C_4 + c_5 + c_8)n - (c_2 + c_4 + c_5 + c_8)
  \end{split}\end{equation}
  $$
  直接把该运行时间表示为$an+b$，其中$a, b$为常量，所以它是$n$的线性函数。

- 最坏情况：输入数组已经提前反向排序。这时，我们必须将每个元素$A[j]$与整个已排序子数组$A[1..j-1]$中的每个元素进行比较，所以对$j=2, 3, ..., n$，有$t_j = j$。注意到：

  $\sum_{j=2}^{n}j = \frac{n(n+1)}{2} - 1$和$\sum_{j=2}^{n}(j-1) = \frac{n(n-1)}{2}$。在最坏情况下，INSORTION-SORT的运行时间为：
  $$
  \begin{equation}\begin{split} 
  T(n) &= c_1n + c_2(n - 1) + c_4(n - 1) + c_5(\frac{n(n+1)}{2} - 1) + c_6(\frac{n(n-1)}{2}) + c_7(\frac{n(n-1)}{2}) + c_8(n-1) \\
  &= (\frac{c_5}{2} + \frac{c_6}{2} + \frac{c_7}{2})n^2 + (c_1 + c_2 + c_4 + \frac{c_5}{2} - \frac{c_6}{2} - \frac{c_7}{2} + c_8)n - (c_2 + c_4 + c_5 + c_8)
  \end{split}\end{equation}
  $$
  直接把该运行时间表示为$an^2 + bn + c$，其中常量$a, b, c$依赖于语句代价$c_i$。因此它是$n$的二次函数。

对于一个问题的算法分析，往往只需要集中于求最坏情况运行时间：

- 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。知道了这个界，就能确保该算法绝不需要更长的时间。
- 对于某些算法，最坏情况经常出现。
- 平均情况往往与最坏情况大致一样差。



## 2.3 设计算法

### 2.3.1 分治法

分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。

分治模式再每层递归时有以下步骤：

1. **分解**原问题为若干子问题，这些子问题是原问题的规模较小的实例。
2. **解决**这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。
3. **合并**这些子问题的解成原问题的解。

例：

![2_4](res/2_4.png)

### 2.3.2 分析分治算法

我们假设$T(n)$是规模为$n$的一个问题的运行时间。若问题规模足够小，如对某个常量$c, n \leqslant c$，则直接求解需要常量时间，我们将其写作$\theta(1)$。假设把原问题分解成$a$个子问题，每个子问题的规模是原问题的$1/b$。（对归并排序，$a$和$b$都为2，然而，我们将看到在许多分治算法中，$a \neq b$。）为了求解一个规模为$n/b$的子问题，需要$T(n/b)$的时间，所以需要$aT(n/b)$的时间来求解$a$个子问题。如果分解问题成子问题需要时间$D(n)$，合并子问题的解成原问题的解需要时间$C(n)$，那么得到递归式：
$$
T(n) =
\begin{cases}
\theta(1) & 若 n \leqslant c \\
aT(n/b) + D(n) + C(n) & 其它
\end{cases}
$$
例，求解递归式：

![2_5](res/2_5.png)

