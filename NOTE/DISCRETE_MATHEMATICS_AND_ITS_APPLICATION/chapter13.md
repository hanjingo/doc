# CHAPTER13 Modeling Computation

[TOC]



## Languages and Grammars

**Definition** A `vocabulary`(or `alphabet`) $V$ is a finite, nonempty set of elements called `symbols`. A `word`(or `sentence`) over $V$ is a string of finite length of elements of $V$. The `empty string` or `null string`, denoted by $\lambda$ (and sometimes by $\epsilon$), is the string containing no symbols. The set of all words over $V$ is denoted by $V^{*}$. A `language over` $V$ is a subset of $V^{*}$.

**Definition** A `phrase-structure grammar` $G = (V, T, S, P)$ consists of a vocabulary $V$, a subset $T$ of $V$ consisting of terminal symbols, a start symbol $S$ from $V$, and a finite set of productions $P$. The set $V - T$ is denoted by $N$. Elements of $N$ are called `nonterminal symbols`. Every production in $P$ must contain at least one nonterminal on its left side.

**Definition** Let $G = (V, T, S, P)$ be a phrase-structure grammar. Let $w_0 = l z_0 r$ (this is, the concatenation of $l, z_0$, and $r$) and $w_1 = l z_1 r$ be strings over $V$. If $z_0 \rightarrow z_1$ is a production of $G$, we say that $w_1$ is `directly derivable` from $w_0$ and we write $w_0 \Rightarrow w_1$. If $w_0, w_1, ..., w_n$ are strings over $V$ such that $w_0 \Rightarrow w_1, w_1 \Rightarrow w_2, ..., w_{n - 1} \Rightarrow w_n$, then we say that $w_n$ is `derivable from` $w_0$, and we write $w_0 \overset{*}{\Rightarrow} w_n$. The sequence of steps used to obtain $w_n$ from $w_0$ is called a `derivation`.

**Definition** Let $G = (V, T, S, P)$ be a phrase-structure grammar. The `language generated by` $G$ (or the `language of` $G$), denoted by $L(G)$, is the set of all strings of terminals that are derivable from the starting state $S$. In other words: $L(G) = \{w \in T^{*} | S \overset{*}{\Rightarrow} w\}$.



## Finite-State Machines with Output

**Definition** A `finite-state machine` $M = (S, I, O, f, g, s_0)$ consists of a finite set $S$ of `states`, a finite `input alphabet` $I$, a finite `output alphabet` $O$, a `transition function` $f$ that assigns to each state and input pair a new state, an `output function` $g$ that assigns to each state and input pair an output, and an `initial state` $s_0$.

**Definition** Let $M = (S, I, O, f, g, s_0)$ be a finite-state machine and $L \subseteq I^{*}$. We say that $M$ `recognize (or accepts)` $L$ if an input string $x$ belongs to $L$ if and only if the last output bit produced by $M$ when given $x$ as input is a 1.



## Finite-State Machines with No Output

**Definition** Suppose that $A$ and $B$ are subsets of $V^{*}$, where $V$ is a vocabulary. The `concatenation` of $A$ and $B$, denoted by $AB$, is the set of all strings of the form $xy$, where $x$ is a string in $A$ and $y$ is a string in $B$.

**Definition** Suppose that $A$ is a subset of $V^{*}$. Then the `Kleene closure` of $A$, denoted by $A^{*}$, is the set consisting of concatenations of arbitrarily many string from $A$. That is, $A^* = \bigcup_{k=0}^{\infty} A^k$

**Definition** A `finite-state automaton` $M = (S, I, f, s_0, F)$ consists of a finite set $S$ of `state`, a finite `input alphabet` $I$, a $\text{transition function } f$ that assigns a next state to every pair of state and input (so that $f: S \times I \rightarrow S$), an $initial$ or $\text{start state } s_0$, and a subset $F$ of $S$ consisting of `final` (or `accepting states`).

**Definition** A string $x$ is said to be `recognized` or `accepted` by the machine $M = (S, I, f, s_0, F)$ if it takes the initial state $s_0$ to a final state, that is, $f(s_0, x)$ is a state in $F$. The `language recognized` or `accepted` by the machine $M$, denoted by $L(M)$, is the set of all strings that are recognized by $M$. Two finite-state automata are called `equivalent` if they recognize the same language.

**Definition** A `nondeterministic finite-state automaton` $M = (S, I, f, s_0, F)$ consists of a set $S$ of states, an input alphabet $I$, a transition function $f$ that assigns a set of states to each pair of state and input (so that $f: S \times I \rightarrow P(S)$), a starting state $s_0$, and a subset $F$ of $S$ consisting of the final states.

**THEOREM** If the language $L$ is recognized by a nondeterministic finite-state automaton $M_0$, then $L$ is also recognized by a deterministic finite-state automaton $M_1$.



## Language Recognition

**Definition** The `regular expressions` over a set $I$​ are defined recursively by:

- the symbol $\emptyset$ is a regular expression;
- the symbol $\lambda$ is a regular expression;
- the symbol $x$ is a regular expression whenever $x \in I$​;
- the symbol ($AB$), ($A \cup B$), and $A^{*}$ are regular expressions whenever $A$ and $B$ are regular expressions.

**THEOREM** KLEEN'S THEOREM: A set is regular if and only if it is recognized by a finite-state automaton.

**THEOREM** A set is generated by a regular grammar if and only if it is a regular set.



## Turing Machines

**Definition** A Turing machine $T = (S, I, f, s_0)$ consists of a finite set $S$ of states, and alphabet $I$ containing the blank symbol $B$, a partial function $f$ from $S \times I$ to $S \times I \times \{R, L\}$, and a starting state $s_0$.

**Definition** Let $V$ be a subset of an alphabet $I$. A Turing machine $T = (S, I, f, s_0)$ recognizes a string $x$ in $V^{*}$ if and only if $T$, starting in the initial position when $x$ is written on the tape, halts in a final state. $T$ is said to recognize a subset $A$ of $V^{*}$ if $x$ is recognized by $T$ if and only if $x$ belongs to $A$.

**Definition** A `decision problem` asks whether statements from a particular class of statements are true. Decision problems are also known as `yes-or-no` problems.

**Definition** The `halting problem` is the decision problem that asks whether a Turing machine $T$ eventually halts when given an input string $x$.

**THEOREM** The halting problem is an unsolvable decision problem. That is, no Turing machine exists that, when given an encoding of a Turing machine $T$ and its input string $x$ as input, can determine whether $T$ eventually halts when started with $x$ written on its tape.

**Definition** A decision problem is in $P$ the `class of polynomial-time problems`, if it can be solved by a deterministic Turing machine in polynomial time in terms of the size of its input. That is, a decision problem is in $P$ if there is a deterministic Turing machine $T$ that solves the decision problem and a polynomial $p(n)$ such that for all integers $n$, $T$ halts in a final state after no more than $p(n)$ transitions whenever the input to $T$ is a string of length $n$. A decision problem is in $NP$, the `class of nondeterministic polynomial-time problems`, if it can be solved by a nondeterministic Turing machine in polynomial time in terms of the size of its input. That is, a decision problem is in $NP$ if there is a nondeterministic Turing machine $T$ that solves the problem and a polynomial $p(n)$ such that for all integers $n$, $T$ halts for every choice of transitions after no more than $p(n)$ transitions whenever the input to $T$ is a string of length $n$.