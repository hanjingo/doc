# CHAPTER13 Modeling Computation

[TOC]



## Languages and Grammars

**Definition** A `vocabulary`(or `alphabet`) $V$ is a finite, nonempty set of elements called `symbols`. A `word`(or `sentence`) over $V$ is a string of finite length of elements of $V$. The `empty string` or `null string`, denoted by $\lambda$ (and sometimes by $\epsilon$), is the string containing no symbols. The set of all words over $V$ is denoted by $V^{*}$. A `language over` $V$ is a subset of $V^{*}$.

**Definition** A `phrase-structure grammar` $G = (V, T, S, P)$ consists of a vocabulary $V$, a subset $T$ of $V$ consisting of terminal symbols, a start symbol $S$ from $V$, and a finite set of productions $P$. The set $V - T$ is denoted by $N$. Elements of $N$ are called `nonterminal symbols`. Every production in $P$ must contain at least one nonterminal on its left side.

**Definition** Let $G = (V, T, S, P)$ be a phrase-structure grammar. Let $w_0 = l z_0 r$ (this is, the concatenation of $l, z_0$, and $r$) and $w_1 = l z_1 r$ be strings over $V$. If $z_0 \rightarrow z_1$ is a production of $G$, we say that $w_1$ is `directly derivable` from $w_0$ and we write $w_0 \Rightarrow w_1$. If $w_0, w_1, ..., w_n$ are strings over $V$ such that $w_0 \Rightarrow w_1, w_1 \Rightarrow w_2, ..., w_{n - 1} \Rightarrow w_n$, then we say that $w_n$ is `derivable from` $w_0$, and we write $w_0 \overset{*}{\Rightarrow} w_n$. The sequence of steps used to obtain $w_n$ from $w_0$ is called a `derivation`.

**Definition** Let $G = (V, T, S, P)$ be a phrase-structure grammar. The `language generated by` $G$ (or the `language of` $G$), denoted by $L(G)$, is the set of all strings of terminals that are derivable from the starting state $S$. In other words: $L(G) = \{w \in T^{*} | S \overset{*}{\Rightarrow} w\}$.



## Finite-State Machines with Output

**Definition** A `finite-state machine` $M = (S, I, O, f, g, s_0)$ consists of a finite set $S$ of `states`, a finite `input alphabet` $I$, a finite `output alphabet` $O$, a `transition function` $f$ that assigns to each state and input pair a new state, an `output function` $g$ that assigns to each state and input pair an output, and an `initial state` $s_0$.

**Definition** Let $M = (S, I, O, f, g, s_0)$ be a finite-state machine and $L \subseteq I^{*}$. We say that $M$ `recognize (or accepts)` $L$ if an input string $x$ belongs to $L$ if and only if the last output bit produced by $M$ when given $x$ as input is a 1.



## Finite-State Machines with No Output

**Definition** Suppose that $A$ and $B$ are subsets of $V^{*}$, where $V$ is a vocabulary. The `concatenation` of $A$ and $B$, denoted by $AB$, is the set of all strings of the form $xy$, where $x$ is a string in $A$ and $y$ is a string in $B$.

**Definition** Suppose that $A$ is a subset of $V^{*}$. Then the `Kleene closure` of $A$, denoted by $A^{*}$, is the set consisting of concatenations of arbitrarily many string from $A$. That is, $A^* = \bigcup_{k=0}^{\infty} A^k$

**Definition** A `finite-state automaton` $M = (S, I, f, s_0, F)$ consists of a finite set $S$ of `state`, a finite `input alphabet` $I$, a $\text{transition function } f$ that assigns a next state to every pair of state and input (so that $f: S \times I \rightarrow S$), an $initial$ or $\text{start state } s_0$, and a subset $F$ of $S$ consisting of `final` (or `accepting states`).

**Definition** A string $x$ is said to be `recognized` or `accepted` by the machine $M = (S, I, f, s_0, F)$ if it takes the initial state $s_0$ to a final state, that is, $f(s_0, x)$ is a state in $F$. The `language recognized` or `accepted` by the machine $M$, denoted by $L(M)$, is the set of all strings that are recognized by $M$. Two finite-state automata are called `equivalent` if they recognize the same language.

**Definition** A `nondeterministic finite-state automaton` $M = (S, I, f, s_0, F)$ consists of a set $S$ of states, an input alphabet $I$, a transition function $f$ that assigns a set of states to each pair of state and input (so that $f: S \times I \rightarrow P(S)$), a starting state $s_0$, and a subset $F$ of $S$ consisting of the final states.

**THEOREM** If the language $L$ is recognized by a nondeterministic finite-state automaton $M_0$, then $L$ is also recognized by a deterministic finite-state automaton $M_1$.



## Language Recognition

**Definition** The `regular expressions` over a set $I$​ are defined recursively by:

- the symbol $\emptyset$ is a regular expression;
- the symbol $\lambda$ is a regular expression;
- the symbol $x$ is a regular expression whenever $x \in I$​;
- the symbol ($AB$), ($A \cup B$), and $A^{*}$ are regular expressions whenever $A$ and $B$ are regular expressions.

**THEOREM** KLEEN'S THEOREM: A set is regular if and only if it is recognized by a finite-state automaton.

**THEOREM** A set is generated by a regular grammar if and only if it is a regular set.



## Turing Machines

**Definition** A Turing machine $T = (S, I, f, s_0)$ consists of a finite set $S$ of states, and alphabet $I$ containing the blank symbol $B$, a partial function $f$ from $S \times I$ to $S \times I \times \{R, L\}$, and a starting state $s_0$.

**Definition** Let $V$ be a subset of an alphabet $I$. A Turing machine $T = (S, I, f, s_0)$ recognizes a string $x$ in $V^{*}$ if and only if $T$, starting in the initial position when $x$ is written on the tape, halts in a final state. $T$ is said to recognize a subset $A$ of $V^{*}$ if $x$ is recognized by $T$ if and only if $x$ belongs to $A$.

**Definition** A `decision problem` asks whether statements from a particular class of statements are true. Decision problems are also known as `yes-or-no` problems.

**Definition** The `halting problem` is the decision problem that asks whether a Turing machine $T$ eventually halts when given an input string $x$.

**THEOREM** The halting problem is an unsolvable decision problem. That is, no Turing machine exists that, when given an encoding of a Turing machine $T$ and its input string $x$ as input, can determine whether $T$ eventually halts when started with $x$ written on its tape.

**Definition** A decision problem is in $P$ the `class of polynomial-time problems`, if it can be solved by a deterministic Turing machine in polynomial time in terms of the size of its input. That is, a decision problem is in $P$ if there is a deterministic Turing machine $T$ that solves the decision problem and a polynomial $p(n)$ such that for all integers $n$, $T$ halts in a final state after no more than $p(n)$ transitions whenever the input to $T$ is a string of length $n$. A decision problem is in $NP$, the `class of nondeterministic polynomial-time problems`, if it can be solved by a nondeterministic Turing machine in polynomial time in terms of the size of its input. That is, a decision problem is in $NP$ if there is a nondeterministic Turing machine $T$ that solves the problem and a polynomial $p(n)$ such that for all integers $n$, $T$ halts for every choice of transitions after no more than $p(n)$ transitions whenever the input to $T$ is a string of length $n$.



## KeyTerms and Results

### TERMS

- **AB(concatenation of A and B)**: the set of all strings formed by concatenating a string in A and a string in B in that order.
- **$A^{*} $ (Kleene closure of A)**: the set of all strings made up by concatenating arbitrarily many strings from A.
- **Alphabet (or vocabulary)**: a set that contains elements used to form strings.
- **Backus-Naur form**: a description of a context-free grammar in which all productions having the same nonterminal as their left-hand side are combined with the different right-hand sides of these productions, each separated by a bar, with nonterminal symbols enclosed in angular brackets and the symbol $\rightarrow$ replaced by $::=$.
- **Computable function**: a function whose values can be computed using a Turing machine.
- **Decision problem**: a problem that asks whether statements from a particular class of statements are true.
- **Derivation (or parse) tree**: an ordered rooted tree where the root represents the starting symbol of a type 2 grammar, internal vertices represent nonterminals, leaves represent terminals, and the children of a vertex are the symbols on the right side of a production, in order from left to right, where the symbol represented by the parent is on the left-hand side.
- **Deterministic finite-state automaton $(S, I, f, s_0, F)$**: a five-tuple containing a set $S$ of states, an input alphabet $I$, a transition function $f$ that assigns a next state to every pair of a state and an input, a starting state $s_0$, and a set of final states $F$.
- **Finite-state machine $(S, I, O, f, g, s_0)$ (or a Mealy machine)**: a six-tuple containing a set $S$ of states, an input alphabet $I$, an output alphabet $O$, a transition function $f$ that assigns a next state to every pair of a state and an input, an output function $g$ that assigns an output to every pair of a state and an input, and a starting state $s_0$.
- **Language**: a subset of the set of all strings over an alphabet.
- **Language recognized by an automaton**: the set of input strings that take the start state to a final state of the automaton.
- **Nondeterministic finite-state automation $(S, I, f, s_0, F)$**: a five-tuple containing a set $S$ of states, an input alphabet $I$, a transition function $f$ that assigns a set of possible next states to every pair of a state and an input, a starting state $s_0$, and a set of final states $F$.
- **Nondeterministic Turing machine**: a Turing machine that may have more than one transition rule corresponding to each (state, tape symbol) pair.
- **Phrase-structure grammar $(V, T, S, P)$**: a description of a language containing a alphabet $V$, a set of terminal symbols $T$, a start symbol $S$, and a set of productions $P$.
- **Regular expression**: an expression defined recursively by specifying that $\theta$, $\lambda$, and $x$, for all $x$ in the input alphabet, are regular expressions, and that $(AB)$, $(A \cup B)$, and $A^{*}$ are regular expressions when $A$ and $B$ are regular expressions.
- **Regular set**: a set defined by a regular expression.
- **Solvable problem**: a problem with the property that there is an effective algorithm that can solve all instances of the problem.
- **The production $w \rightarrow w_1$**: $w$ cna be replaced by $w_1$ whenever it occurs in a string in the language.
- **Turing machine $T = (S, I, f, s_0)$**: a four-tuple consisting of a finite set $S$ of states, an alphabet $I$ containing the blank symbol $B$, a partial function $f$ from $S \times I$ to $S \times I \times \{R, L\}$, and a starting state $s_0$.
- **Type 0 grammar**: any phrase-structure grammar.
- **Type 1 grammar**: a phrsae-structure grammar in which every production is of the form $w_1 \rightarrow w_2$, where $w_1 = lAr$ and $w_2 = lwr$, where $A \in N, l, r, w \in (N \cup T) * and w \neq \lambda$, or $w_1 = S$ and $w_2 = \lambda$ as long as $S$ is not on the right-hand side of another production.
- **Type 2, or context-free, grammar**: a phrase-structure grammar in which every production is of the form $A \rightarrow w_1$, where $A$ is a nonterminal symbol.
- **Type 3, or regular, grammar**: a phrase-structure grammar where every production is of the form $A \rightarrow aB$, $A \rightarrow a$, or $S \rightarrow \lambda$, where $A$ and $B$ are nonterminal symbols, $S$ is the start symbol, and $a$ is a terminal symbol
- **Uncomputable function**: a function whose values cannot be computed using a Turing machine.
- **Unsolvable problem**: a problem with the property that no effective algorithm exists that can solve all instances of the problem.
- **$w_1 \Rightarrow w_2$ ($w_2$ is directly derivable from $w_1$)**: $w_2$ can be obtained from $w_1$ using a production to replace a string in $w_1$ with another string.
- **$w_1 \Rightarrow^* w_2$($w_2$ is derivable from $w_1$)**: $w_2$ can be obtained from $w_1$ using a sequence of productions ot replace strings by other strings.
- **P, the class of polynomial-time problems**: the class of problems that can be solved by a deterministic Turing machine in polynomial time in terms of the size of the input.
- **NP, the class of nondeterministic polynomial-time problems**: the class of problems that can be solved by a nondeterministic Turing machine in polynomial time in terms of the size of the input.
- **NP-complete**: a subset of the class of NP problems with the property that if any one of them is in the class $P$, then all problems in $NP$ are in the class $P$.

### RESULTS

For every nondeterministic finite-state automaton there is a deterministic finite-state automaton that recognizes the same set.

**Kleene's theorem**: A set is regular if and only if there is a finite-state automaton that recognizes it.

A set is regular if and only if it is generated by a regular grammar.

The halting problem is unsolvable.