# 引言

## 什么是设计模式

一个模式有4个基本要素:

1. 模式名称(pattern name)
> 用来描述模式的问题

2. 问题(problem)
> 描述应该在何时使用模式

3. 解决方案(solution)
> 描述了设计的组成成分

4. 效果(consequences)
> 描述了模式应用的效果以及使用模式应权衡的问题

---

## Smalltalk MVC中的设计模式
MVC(Model/View/Controller)

---

## 描述设计模式
- 模式名和分类
- 意图
- 别名
- 动机
- 适用性
- 结构
- 参与者
- 协作
- 效果
- 实现
- 代码示例
- 已知应用
- 相关模式

---

## 设计模式的编目
- Abstract Factory(抽象工厂模式)

提供了一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

- Adapter(适配器模式)

将一个类的接口转换成客户希望的另一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

- Bridge(桥接模式)

将抽象部分与它的实现部分分离，使它们都可以独立地变化。

- Builder(构建者模式)

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

- Chain of Responsibility()

为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。

- Command(命令模式)

将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。

- Composite(组合模式)

将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和符合对象的使用具有一致性。

- Decorator(装饰模式)

动态的给一个对象添加一些额外的职责。

- Facade(外观模式)

为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更容易使用。

- Factory Method(工厂方法模式)

定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使一个类的实例化延迟到其子类。

- Flyweight(享元模式)

运用共享技术有效地支持大量细粒度的对象。

- Interpreter(解释器模式)

给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

- Iterator(迭代器模式)

给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

- Mediator(中介者模式)

用一个中介对象来封装一些列的对象互交。中介者使各对象不需要显式的相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。

- Memento(备忘录模式)

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。

- Observer(观察者设计模式)

定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。

- Prototype(原型模式)

用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

- Proxy(代理模式)

为其他对象提供一个代理以控制对这个对象的访问。

- Singleton(单例模式)

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

- State(状态模式)

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。

- Strategy(策略模式)

定义一系列的算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法的变化可独立于使用它的客户。

- Template Method(模板方法模式)

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

- visitor(访问者模式)

表示一个作用于某对象结构中的各元素的操作。

---

## 组织编目
设计模式空间

|-|创建型|结构型|行为型|
|--|--|--|--|
|类|Factory Method|Adapter|Interpreter<br>Template Method|
|对象|Abstract Factory<br>Builder<br>Prototype<br>Singleton|Adapter<br>Bridge<br>Composite<br>Decorator<br>Facade<br>Flyweight<br>Proxy|Chain of Responsibility<br>Command<br>Iterator<br>Mediator<br>Memento<br>Observer<br>State<br>Strategy<br>Visitor|

![1-1 设计模式之间的关系]()

---

## 设计模式怎样解决设计问题

### 寻找合适的对象
面向对象程序由休想组成，对象包括数据和对数据进行操作的过程，过程通常称为方法或操作。对象在收到客户的的请求(或消息)后，执行相应的操作。

### 指定对象接口
- 类型(type): 用来表示特定接口的一个名字。
- 子类型(subtype): 被包含的接口。
- 超类型(supertype): 包含另一个类型的接口的类型。
- 动态绑定(dynamic binding): 发送给对象的请求和它的相应操作在运行时刻的连接。
- 多态(polymorphism): 动态绑定允许你在运行时刻彼此替换有相同接口的对象，这种可替换性就叫多态。

### 描述对象的实现

抽象类(abstract class)的主要目的是为他的子类定义公共接口。

在抽象类中定义却没有实现的操作就成为抽象操作(abstract operation)。

非抽象类称为具体类(concrete class)。

混入类(mixin class)是给其他类提供可选择的接口或功能的类。

### 运用复用集质
1. 继承和组合的比较
> 面向对象系统中功能服用的两种最常用技术是类继承和对象组合(object composition)。
> 类继承允许根据其他类的实现来定义一个类的实现。这种通过生成子类的复用通常称为白箱复用(white-box reuse)。
> 新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种服用风格被称为黑箱复用(black-box reuse)。
> **优先使用对象组合，而不是类继承**

2. 委托
> 委托(delegation)是一种组合方法，它使组合具有与继承同样的复用能力。

3. 继承和参数化类型的比较
> 另一种功能复用计数(并非严格的面向对象技术)使参数化类型(parameterized type),也就是类属(generic)或模板(templates)。它允许你在定义一个类型时并不指定该类型所用道德其他所有类型。


