# 第一章 引言

[TOC]

## 1.1 什么是设计模式

一个模式有4个基本要素:

1. 模式名称(pattern name)

   用来描述模式的问题。

2. 问题(problem)

   描述应该在何时使用模式。

3. 解决方案(solution)

   描述了设计的组成成分。

4. 效果(consequences)

   描述了模式应用的效果以及使用模式应权衡的问题。



## 1.2 Smalltalk MVC中的设计模式

MVC(Model/View/Controller)



## 1.3 描述设计模式

- 模式名和分类
- 意图
- 别名
- 动机
- 适用性
- 结构
- 参与者
- 协作
- 效果
- 实现
- 代码示例
- 已知应用
- 相关模式



## 1.4 设计模式的编目

- Abstract Factory(抽象工厂模式)

  提供了一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

- Adapter(适配器模式)

  将一个类的接口转换成客户希望的另一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

- Bridge(桥接模式)

  将抽象部分与它的实现部分分离，使它们都可以独立地变化。

- Builder(构建者模式)

  将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

- Chain of Responsibility()

  为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。

- Command(命令模式)

  将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。

- Composite(组合模式)

  将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和符合对象的使用具有一致性。

- Decorator(装饰模式)

  动态的给一个对象添加一些额外的职责。

- Facade(外观模式)

  为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更容易使用。

- Factory Method(工厂方法模式)

  定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使一个类的实例化延迟到其子类。

- Flyweight(享元模式)

  运用共享技术有效地支持大量细粒度的对象。

- Interpreter(解释器模式)

  给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

- Iterator(迭代器模式)

  给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

- Mediator(中介者模式)

  用一个中介对象来封装一些列的对象互交。中介者使各对象不需要显式的相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。

- Memento(备忘录模式)

  在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。

- Observer(观察者设计模式)

  定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。

- Prototype(原型模式)

  用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

- Proxy(代理模式)

  为其他对象提供一个代理以控制对这个对象的访问。

- Singleton(单例模式)

  保证一个类仅有一个实例，并提供一个访问它的全局访问点。

- State(状态模式)

  允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。

- Strategy(策略模式)

  定义一系列的算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法的变化可独立于使用它的客户。

- Template Method(模板方法模式)

  定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

- visitor(访问者模式)

  表示一个作用于某对象结构中的各元素的操作。



## 1.5 组织编目

设计模式空间：

|      | 创建型                                                | 结构型                                                       | 行为型                                                       |
| ---- | ----------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 类   | Factory Method                                        | Adapter                                                      | Interpreter<br>Template Method                               |
| 对象 | Abstract Factory<br>Builder<br>Prototype<br>Singleton | Adapter<br>Bridge<br>Composite<br>Decorator<br>Facade<br>Flyweight<br>Proxy | Chain of Responsibility<br>Command<br>Iterator<br>Mediator<br>Memento<br>Observer<br>State<br>Strategy<br>Visitor |

![1_1](res/1_1.png)

*设计模式之间的关系*



## 1.6 设计模式怎样解决设计问题

### 1.6.1 寻找合适的对象

面向对象程序由对象组成，对象包括数据和对数据进行操作的过程，过程通常称为方法或操作。对象在收到客户的的请求(或消息)后，执行相应的操作。

### 1.6.2 决定对象的粒度

### 1.6.3 指定对象接口

- `类型(type)` 用来表示特定接口的一个名字。
- `子类型(subtype)` 被包含的接口。
- `超类型(supertype)` 包含另一个类型的接口的类型。
- `动态绑定(dynamic binding)` 发送给对象的请求和它的相应操作在运行时刻的连接。
- `多态(polymorphism)` 动态绑定允许你在运行时刻彼此替换有相同接口的对象，这种可替换性就叫多态。

### 1.6.4 描述对象的实现

`抽象类(abstract class)`的主要目的是为他的子类定义公共接口。

在抽象类中定义却没有实现的操作就成为`抽象操作(abstract operation)`。

非抽象类称为`具体类(concrete class)`。

`混入类(mixin class)`是给其他类提供可选择的接口或功能的类。

- 类继承与接口继承的比较

  一个对象可以有多个类型，不同类的对象可以有相同的类型。

- 对接口编程，而不是对实现编程。

  1. 客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口。

  2. 客户无须知道他们使用的对象是用什么类来实现的，他们只须知道定义接口的抽象类。

### 1.6.5 运用复用机制

1. 继承和组合的比较

   面向对象系统中功能服用的两种最常用技术是类继承和对象组合(object composition)。
   类继承允许根据其他类的实现来定义一个类的实现。这种通过生成子类的复用通常称为白箱复用(white-box reuse)。
   新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种服用风格被称为黑箱复用(black-box reuse)。
   **优先使用对象组合，而不是类继承**

2. 委托

   委托(delegation)是一种组合方法，它使组合具有与继承同样的复用能力。

3. 继承和参数化类型的比较

   另一种功能复用计数(并非严格的面向对象技术)使参数化类型(parameterized type),也就是类属(generic)或模板(templates)。它允许你在定义一个类型时并不指定该类型所用到的其他所有类型。未经指定的类型在使用时以参数形式提供。

### 1.6.6 关联运行时刻和编译时刻的结构

- 聚合(aggregation)
  集合意味着一个对象拥有另一个对象或对另一个对象负责。一般我们称一个对象包含另一个对象或者是另一个对象的一部分。聚合意味着聚合对象和其所有者具有相同的生命周期。
- 相识(acquaintance)
  相识意味着一个对象仅仅知道另一个对象。相识的对象可能请求彼此的操作，但是它们不为对方负责。相识是一种比聚合要弱的关系，它只标识了对象间较松散的耦合关系。

C++中，聚合可以通过定义表示真正实例的成员变量来实现，但更通常的是将这些成员变量定义为实例指针或引用；相识也是以指针或引用来实现。

### 1.6.7 设计应支持变化

解决问题的常用设计模式:

1. **通过显式地指定一个类来创建对象** 在创建对象时指定类名将使你受特定实现地约束而不是特定接口的约束。这会使未来的变化更负责。要避免这种情况，应该间接地创建对象。

   设计模式：Abstract Factory, Factory Method, Prototype.

2. **对特殊操作地依赖** 当你为请求指定一个特殊的操作时，完成该请求地方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便的改变响应请求的方法。

   设计模式：Chain of Resposibility, Command

3. **对硬件和软件平台地依赖** 外部地操作系统接口和应用编程接口(API)在不同的软硬件平台上时不同的。依赖于特定平台的软件将很难一直到其它平台上，甚至都很难跟上本地平台地更新。所以设计系统时限制其平台相关性就很重要了。

   设计模式: Abstract Factory, Bridge

4. **对对象标识或实现地依赖** 知道对象怎样表示，保存，定位或实现地客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。

   设计模式：Abstract Factory, Bridge, Memento, Proxy

5. **算法依赖** 算法在开发和复用时常常被扩展，优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化地算法应该被孤立起来。

   设计模式：Builder, Iterator, Strategy, Template Method, Visitor

6. **紧耦合** 紧耦合地类很难独立地被复用，因为他们是相互依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习，移植和维护地密集体。松散耦合提高了一个类本身被复用的可能性，并且系统更已于学习，移植，修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。

   设计模式：Abstract Factory, Command, Facade, Mediator, Observer, Chain of Responsibility

7. **通过生成子类来扩充功能** 通常很难通过定义子类来定制对象。每一个心累都有固定的实现开销(初始化,终止处理等)。定义子类还需要对符类有深入地了解。子类方法会导致类爆炸，因为即使对于一个简单地扩充，你也不得不引用许多新的子类。一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通知以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。另一方面，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能。

   设计模式：Bridge, Chain of Responsibility, Composite, Decorator, Observer, Strategy

8. **不能方便地对类进行修改** 有时你不得不改变一个难以修改的类。

   设计模式：Adapter, Decorator, Visitor

模式和框架地区别:

1. 设计模式比框架更抽象
2. 设计模式是比框架更小的体系结构元素
3. 框架比设计模式更加特例化



## 1.7 怎样选择设计模式

设计模式所支持地设计的可变方面：

| 目的 | 设计模式                                                     | 可变地方面                                                   |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 创建 | Abstract Factory<br>Builder<br>Factory Method<br>Prototype<br>Singleton | 产品对象家族<br>如何创建一个组合对象<br>被实例化地子类<br>被实例化地类<br>一个类地唯一实例 |
| 结构 | Adapter<br>Bridge<br>Composite<br>Decorator<br>Facade<br>Flyweight<br>Proxy | 对象地接口<br>对象地实现<br>一个对象地结构和组成<br>对象的职责，不生成子类<br>一个子系统地接口<br>对象的存储开销<br>如何访问一个对象；该对象地位置 |
| 行为 | Chain of Responsibility<br>Command<br>Interpreter<br>Iterator<br>Mediator<br>Memento<br>Observer<br>State<br>Strategy<br>Template Method<br>Visitor | 满足一个请求的对象<br>何时，怎样满足一个请求<br>一个语言地文法及解释<br>如何遍历，访问一个聚合地各元素<br>对象间怎样互交，和谁互交<br>一个对象中那些私有信息存放在该对象之外，以及在什么时候进行存储<br>多个对象依赖于另一个对象，而这些对象又如何保持一致<br>对象地状态<br>算法<br>算法中的某些步骤<br>某些可作用于一个（组）对象上的操作，但不修改这些对象的类 |



## 1.8 怎样使用设计模式

1. 大致浏览一遍模式
2. 回头研究结构部分，参与者部分和协作部分
3. 看代码示例部分，看看这个模式代码形式地具体例子
4. 选择模式参数与者地名字，使他们在应用上下文中有意义
5. 定义类
6. 定义模式中专用于应用的操作名称
7. 实现执行模式中责任和协作地操作
