# 第十章 多线程程序的测试和调试

[TOC]



## 与并发相关的错误类型

并发相关的错误通常有2大类：

- 不必要阻塞
- 条件竞争

### 不必要阻塞

- 死锁
- 活锁
- `I/O阻塞或外部输入`

### 条件竞争

- 数据竞争

  因为未同步访问一块共享内存，将会导致代码产生未定义行为。

- 破坏不变量

  主要表现为悬空指针（因为其他线程已经将要访问的数据删除了），随机存储错误（因为局部更新，导致线程读取了不一样的数据），以及双重释放（比如：当两个线程对同一个队列同时执行pop操作， 想要删除同一个关联数据），等等。不变量被破坏可以看作“基于数据”的问题。当独立线程需要以一定顺序执行某些操作时，错误的同步会导致条件竞争，比如：顺序被破坏。

- 生命周期问题

   在一个线程引用了局部变量，在线程还没有完成前，局部变量的“死期”就已经到了；
   
   当你手动调用`join()`等待线程完成工作，你需要保证异常抛出的时候，`join()`还会等待其他未完成工作的线程；



## 定位并发错误的技术

### 代码审阅-发现潜在的错误
审阅多线程代码需要考虑的问题：
- 并发访问时，那些数据需要保护？
- 如何确定访问数据受到了保护？
- 是否会有多个线程同时访问这段代码？
- 这个线程获取了哪个互斥量？
- 其他线程可能获取哪些互斥量?
- 两个线程间的操作是否有依赖关系？如何满足这种关系？
- 这个线程加载的数据还是合法数据吗？数据是否被其他线程修改过？
- 当假设其他线程可以对数据进行修改，这将意味着什么？并且，怎么确保这样的事情不会发生？

### 通过测试定位并发相关的错误
测试并发队列需要考虑的问题，例：
- 使用单线程调用`push()`或`pop()`，来去顶在一般情况下队列是否正常工作
- 其他线程调用`pop()`时，使用另一线程在空队列上调用`push()`
- 在空队列上，以多线程的方式调用`push()`
- 在满载队列上，以多线程的方式调用`push()`
- 在空队列上，以多个线程的方式调用`pop()`
- 在满载队列上，以多线程的方式调用`pop()`
- 在非满载队列上（任务数量小于线程数量），以多线程的方式调用`pop()`
- 当一线程在空队列上调用`pop()`的同时，以多线程的方式调用`push()`
- 当一线程在满载队列上调用`pop()`的同时，以多线程的方式调用`push()`
- 当多线程在空队列上调用`pop()`的同时，以多线程方式调用`push()`
- 当多线程在满载队列上调用`pop()`的同时，以多线程方式调用`push()`
- “多线程”是有多少线程（3个，4个，还是1024个？）
- 系统中是否有足够的处理器，能让每个线程运行在属于自己的处理器上
- 测试需要运行在哪种处理器架构上
- 在测试中如何对“同时”进行合理的安排

### 可测试性设计
如果代码满足以下几点，就很容易进行测试：
- 每个函数和类的关系都很清楚。
- 函数短小精悍。
- 测试用例可以完全控制被测试代码周边的环境。
- 执行特定操作的代码应该集中测试，而非分布式测试。
- 需要在完成编写后，考虑如何进行测试。

### 多线程测试技术
- 压力测试
- 组合仿真测试
- 使用专用库对代码进行测试

### 构建多线程测试代码
- 环境布置代码，必须首先执行
- 线程设置代码，需要在每个线程上执行
- 线程上执行的代码，需要有并发性
- 在并发执行结束后，后续代码需要对代码的状态进行断言检查

对一个队列并发调用`push()`和`pop()`的测试用例：

```c++
void test_concurrent_push_and_pop_on_empty_queue()
{
	threadsafe_queue<int> q; // 创建空队列
	std::promise<void>go, push_ready, ppop_ready; // 为准备状态创建promise对象
	std::shared_future<void> ready(go.get_future()); // 为go信号获取一个std::shared_future
	std::future<void> push_done; // 用来标识线程是否结束
	std::future<int> pop_done;

	try
	{
		push_done = std::async(std::launch::async, // 保证每个任务在自己的线程上完成
						       []&q, ready, &push_ready)()
		{
            push_ready.set_value();
			ready.wait();
			q.push(42);
		});
        push_done=std::async(std::launch::async, // 保证每个任务在字节的线程上完成
                             [&q, ready, &pop_ready]()
        {
            pop_ready.set_value();
            ready.wait();
            return q.pop(); 
        });
        push_ready.get_future().wait(); // 等待信号
        pop_ready.get_guture().wait();
        go.set_value(); // 提示所有线程可以开始进行测试

        push_done.get(); // 异步调用等待线程完成
        assert(pop_done.get == 42); 
        assert(q.empty());
	}
    catch(...)
    {
        go.set_value(); // 12
    }
}
```
