# 第二章 协议结构模块

[TOC]



## 协议概述
* `protocol 协议` 是一系列步骤，它包括两方或多方，设计它的目的是要完成一项任务；
* `cryptographic protocol 密码协议` 是使用密码学的协议；
* `arbitrator 仲裁者` 在完成协议中，值得信任的公正的第三方;

### 裁决协议
仲裁协议可以分成2个低级的子协议(subprotocol):
1. `非仲裁子协议` 执行协议的各方每次都想要完成的
2. `仲裁子协议` 仅再例外的情况下，即有争议的时候才执行

### 自动执行协议

`自动执行协议(self-enforcing protocol)` 是协议中最好的。

### 对协议的攻击
1. `被动攻击(passive attack)` 与协议无关的人能够窃听协议的一部分或全部，攻击者不可能影响协议
2. `主动攻击(active attack)` 改变协议以便对自己有利



## 使用对称密码系统通信

### 单向函数

`单向函数(one-way function)` 的概念是公开密钥密码的中心；已知$x$,我们很容易计算$f(x)$;但已知$f(x)$,却难于计算$x$。

`陷门单向函数(trapdoor one-way function)` 是有一个秘密陷们的一类特殊的单向函数。它再一个方向上易于计算而反方向却难于计算。但是，如果你知道那个秘密，你也能很容易再另一个方向上计算出这个函数

`单向散列函数(one-way hash function)` 把可变长度输入串(预映射, pre-image)转换成固定长度输出串(散列值,hash value)的函数

`消息鉴别码(Message Authentication Code, MAC)` 也叫数据鉴别码(DAC)，它是带有秘密密钥的单向散列函数



## 使用公开密钥密码系统通信

### 混合密码系统

公开密钥密码用来保护和分发会话密钥(session key)。这些会话密钥用在对称算法中，对通信信息进行保密。有时称这种系统为混合密码系统(hybrid cryptosystem)。
1. B将他的公开密钥发送给A。
2. A产生随机会话密钥K，用B的公开密钥加密，并把加密的密钥$$D=B(E=B(K)) = k$$。
3. B用他的私人密钥解密A的消息，恢复出会话密钥:$$D=B(E=B(K)) = K。
4. 他们2人用同一个会话密钥对他们的通信消息进行加密。

### 使用堆成密码系统和仲裁者对文件签名

1. A用$$K=A$$加密他准备发给B的消息，并把它传送给T。
2. T用$$K=A$$揭秘消息。
3. T把这个解密消息和他收到A的消息的声明，一起用$$K=B$$加密。
4. T把加密的消息包发送给B。
5. B用$$K=B$$解密消息包,他就能读A所发的消息和T的证书，证明消息来自A。

### 使用公开密钥密码系统对文件签名

1. A用他的私人密钥对文件加密，从而对文件签名。
2. A将签名的文件传给B。
3. B用A的公开密钥解密文件，从而验证签名。

### 使用公开密钥密码系统和单向散列函数对文件签名

1. A产生文件的单向散列值
2. A用他的私人密钥对散列值加密，由此对文件签名
3. A将文件和签名的散列值发送给B
4. B用A发送的文件产生文件的单向散列值，然后用数字签名算法对散列值进行运算，同时用A的公开密钥对签名的散列值解密

### 多重签名

1. A对文件的散列签名
2. B对文件的散列签名
3. B将他的签名交给A
4. A把文件，他的签名和B的签名发给C
5. C验证A和B的签名

### 抗抵赖和数字签名

1. A对消息签名
2. A产生一个报头，报头中包含有些鉴别消息。他把报头和签名的消息连接起来，对连接的消息签名，然后把签名的消息发给T
3. T验证外面的签名，并确认鉴别消息。他在A签名消息中增加一个时间标记和鉴别消息。然后对所有的消息签名，并把它发送给B和A
4. B验证T的签名，鉴别消息和A的签名
5. A验证T发给B的消息



## 带加密的数字签名

### 重新发送消息作为收据

通过把公开密钥密码和数字签名结合起来，能够产生一个协议，可以把数字签名的真实性和加密的安全性结合起来。

**签名:**

1. A用他的私人密钥对消息签名: $$S=A(M)$$
2. A用B的公开密钥对签名的消息加密，然后发送给B: $$E=B(S=A(M))$$
3. B用他的私人密钥解密: $$D=B(E=B(S=A(M)))=S=A(M)$$
4. B用A的公开密钥验证并恢复消息: $$V=A(S=A(M))=M$$

**确认**
1. A用他的私人密钥对消息签名，再用B的公开密钥加密，然后传给B: $$E=B(S=A(M))$$
2. B用他的私人密钥对消息解密，并用A的公开密钥验证签名，由此验证确实时A对消息签名，并恢复消息: $$V=B(D=B(E=B(S=A(M))))=M$$
3. B用他的私人密钥对消息签名，用A的公开密钥加密，再把它发送回A: $$E=A(S=B(M))$$
4. A用他的私人密钥对消息解密，并用B的公开密钥对验证B的签名。如果接收的消息与他传给B的相同，他就知道B准确的接收到了他所发送的消息

### 阻止重新发送攻击

1. A对消息签名
2. A用B的公开密钥对消息和签名加密（采用和签名算法不同的加密算法），然后将它传送给B
3. B用他的私人密钥对消息解密
4. B验证A的签名



## 随机和伪随机序列的产生

### 密码学意义上安全的伪随机序列

具有以下性质：

- `密码学意义上安全的伪随机序列(crypto-graphically secure pseudo-random sequence)` 它是不可预测的，即使给出产生序列的算法或硬件和所有以前产生的位序列的全部知识，也不可能通过计算来预测下一个随机位是什么。

### 真正的随机序列

`真正的随机(real random)` 它不能重复产生，如果你用完全同样的输入对序列发生器操作两次（至少与人所能做到的最精确的一样），你将得到两个不相关的随机序列。

