# 并发编程
1. atomic库封装了操作系统的底层原语，可以高效地执行原子化操作，避免了线程锁的代价，是编写多CPU内核并发程序不可缺少的重要工具。
2. thread库现在是c++标准的一部分，他使用多个成熟的范式为我们提供了可移植的多线程处理能力。c++历来缺乏操作线程的能力，经常要求助于C API，而现在thread库填补了这个空白。
3. thread库实现了目前多线程编程所需要的绝大部分概念，包括互斥锁，递归锁，读写锁，条件变量，线程，future，barrier等，还有一些正在开发中的synchronized_value,synchronized_queue等实验性功能，其接口非常方便易用，他还能配合ref,bind/lambda,function等其他标准库组件或Boost组件提供更加灵活，优雅的解决方案。
4. 拥有了thread库这个强有力的武器，C++程序员只需要再了解一些多线程开发的基本规则就能轻而易举地构建出高效的多线程程序。
5. asio库使用前摄器模式实现了同步或异步的IO操作，提供了UNIX信号，定时器，网络通信，串口通信等许多IO操作，并且支持使用协程来简化异步代码的编写。
6. 前摄器模式非常复杂，而asio基于操作系统的异步IO能力简洁而高效的实现了前摄器模式，并且将细节封装在io_service,signal_set等对象中，使库用户得到了一个高度可用的接口。asio还很好地封装了Socket_API，完整地支持TCP/UDP/ICMP等通信协议，有效的避免了误用复杂的原始Socket API的问题，asio将来很有可能被纳入C++标准，成为标准的网络底层库。
7. thread库和asio库都可以用于并发编程，但他们解决问题的途径不一样。thread使用的是进程内部的线程机制，很少需要操作系统内核干预，只要掌握了线程的同步方法，多线程程序的结构很容易理解，也很容易实现。而asio使用的是异步事件处理机制，与操作系统的内核密切相关，使用它需要对操作系统的底层机制有一定的了解，比多线程程序更难于编写，也难于调试，但由于asio把异步操作的管理工作交由操作系统处理，所以能够获得更高的运行性能。
8. thread和asio有竞争也有合作，可以在多线程环境中同步的使用asio,既能获得并发处理能力又能避免涉及复杂的异步调用机制，还可以在asio异步调用中启动多线程，使异步操作可以运行于多个线程中。