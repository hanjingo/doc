# 第20章 智能指针


<!-- vim-markdown-toc GFM -->

* [20.1 holder和trule](#201-holder和trule)
    - [20.1.1 安全处理异常](#2011-安全处理异常)
    - [20.1.2 holder](#2012-holder)
    - [20.1.3 作为成员的holder](#2013-作为成员的holder)
    - [20.1.4 资源获取于初始化](#2014-资源获取于初始化)
    - [20.1.5 holder的局限](#2015-holder的局限)
    - [20.1.6 复制holder](#2016-复制holder)
    - [20.1.7 跨函数调用来复制holder](#2017-跨函数调用来复制holder)
    - [20.1.8 trule](#2018-trule)
* [20.2 引用记数](#202-引用记数)
    - [20.2.1 计数器在什么地方](#2021-计数器在什么地方)
    - [20.2.2 并发访问计数器](#2022-并发访问计数器)
    - [20.2.3 析构和释放](#2023-析构和释放)
    - [20.2.4 CountingPtr模版](#2024-countingptr模版)
    - [20.2.5 一个简单的非侵入式计数器](#2025-一个简单的非侵入式计数器)
    - [20.2.7 常数性](#2027-常数性)
    - [20.2.8 隐式转型](#2028-隐式转型)
    - [20.2.9 比较](#2029-比较)
* [20.3 本章后记](#203-本章后记)

<!-- vim-markdown-toc -->


智能指针是一些在行为上类似于普通指针的类，而且该类海风装了一些内存管理或资源管理policy。

两种不同所有权模型：

- 独占：与直接操作（原生）指针相比，使用独占模型几乎不需要耗费额外的开销。当操作动态分配的对象时，使用这种policy的智能指针可以用于处理异常抛出。
- 共享：使用共享模型有时会导致非常复杂的对象生命期问题。在这种情况下，我们通常建议让程序自身来处理对象的生命期。

## 20.1 holder和trule

holder类型独占一个对象；而trule可以使对象的拥有者从一个holder传递给另一个holder。

### 20.1.1 安全处理异常

### 20.1.2 holder

### 20.1.3 作为成员的holder

### 20.1.4 资源获取于初始化

### 20.1.5 holder的局限

### 20.1.6 复制holder

### 20.1.7 跨函数调用来复制holder

### 20.1.8 trule



## 20.2 引用记数

引用计数：对于每个被指向的对象，都保存一个计数，用于代表只想该对象的指针的个数，当计数值减少到0时，就删除此对象。

### 20.2.1 计数器在什么地方

### 20.2.2 并发访问计数器

### 20.2.3 析构和释放

### 20.2.4 CountingPtr模版

### 20.2.5 一个简单的非侵入式计数器

### 20.2.7 常数性

### 20.2.8 隐式转型

内建指针可以被用于以下几种隐式转型：

- 到void*类型的转型。
- 到被指向的对象的一个基类指针的转型。
- 到bool类型的转型（若指针为空则为false，否则为true）。

隐式转换缺点：

- delete cp; 以及::delete cp; 都变成有效的了。
- 对于智能指针而言，各种毫无意义的指针算法都将不可确定了。

### 20.2.9 比较



## 20.3 本章后记


