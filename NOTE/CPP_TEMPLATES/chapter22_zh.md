# 第22章 函数对象和回调


<!-- vim-markdown-toc GFM -->

* [22.1 直接调用，间接调用与内联调用](#221-直接调用间接调用与内联调用)
* [22.2 函数指针与函数引用](#222-函数指针与函数引用)
* [22.3 成员函数指针](#223-成员函数指针)
* [22.4 class类型的仿函数](#224-class类型的仿函数)
    - [22.4.1 class类型仿函数的第1个实例](#2241-class类型仿函数的第1个实例)
    - [22.4.2 class类型仿函数的类型](#2242-class类型仿函数的类型)
* [22.5 指定仿函数](#225-指定仿函数)
    - [22.5.2 作为函数调用实参的仿函数](#2252-作为函数调用实参的仿函数)
    - [22.5.3 结合函数调用参数和模版类型参数](#2253-结合函数调用参数和模版类型参数)
    - [22.5.4 作为非类型模板实参的仿函数](#2254-作为非类型模板实参的仿函数)
    - [22.5.5 函数指针的封装](#2255-函数指针的封装)
* [22.6 内省](#226-内省)
    - [22.6.1 分析一个仿函数的类型](#2261-分析一个仿函数的类型)
    - [22.6.2 访问参数的类型](#2262-访问参数的类型)
    - [22.6.3 封装函数指针](#2263-封装函数指针)
* [22.7 函数对象组合](#227-函数对象组合)
    - [22.7.1 简单的组合](#2271-简单的组合)
    - [22.7.2 混合类型的组合](#2272-混合类型的组合)
    - [22.7.3 减少参数的个数](#2273-减少参数的个数)
* [22.8 值绑定](#228-值绑定)
    - [22.8.1 选择绑定的目标](#2281-选择绑定的目标)
    - [22.8.2 绑定签名](#2282-绑定签名)
    - [22.8.3 实参选择](#2283-实参选择)
    - [22.8.4 辅助函数](#2284-辅助函数)
* [22.9 仿函数操作：一个完整的实现](#229-仿函数操作一个完整的实现)
* [22.10 本章后记](#2210-本章后记)

<!-- vim-markdown-toc -->



函数对象：可以使用函数调用语法进行调用的任何对象。

## 22.1 直接调用，间接调用与内联调用

- 直接调用：在编译期可以确定目标的调用，就可以直接调用（例如普通函数调用）。
- 借鉴调用：在编译期无法确定确切的目标的调用，只能在运行期进行目标确定的调用（例如使用函数指针进行调用）。
- 内联调用：把函数的代码在调用点直接展开。

执行效率对比：内联调用>直接调用>间接调用。



## 22.2 函数指针与函数引用



## 22.3 成员函数指针

![22_1](res/22_1.png)

*类型D的典型组织方式*

对于成员函数指针，许多编译器使用了`3-值结构`:

1. 成员函数的地址，如果是一个虚函数的话，那么该值为NULL。
2. 基于this的地址调整。
3. 一个虚函数索引。



## 22.4 class类型的仿函数

### 22.4.1 class类型仿函数的第1个实例

### 22.4.2 class类型仿函数的类型



## 22.5 指定仿函数

### 22.5.2 作为函数调用实参的仿函数

函数调用实参来传递仿函数，允许调用者在运行期构造函数对象。

### 22.5.3 结合函数调用参数和模版类型参数

### 22.5.4 作为非类型模板实参的仿函数

### 22.5.5 函数指针的封装



## 22.6 内省

### 22.6.1 分析一个仿函数的类型

要求框架可以提供以下这些与仿函数相关的属性：

- 仿函数参数的个数。
- 仿函数每个参数的类型。
- 仿函数的返回类型。

### 22.6.2 访问参数的类型

### 22.6.3 封装函数指针



## 22.7 函数对象组合

### 22.7.1 简单的组合

### 22.7.2 混合类型的组合

### 22.7.3 减少参数的个数



## 22.8 值绑定

### 22.8.1 选择绑定的目标

### 22.8.2 绑定签名

### 22.8.3 实参选择

### 22.8.4 辅助函数



## 22.9 仿函数操作：一个完整的实现



## 22.10 本章后记


