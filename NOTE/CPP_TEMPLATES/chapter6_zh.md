# Chapter6 模板实战


<!-- vim-markdown-toc GFM -->

* [6.1 包含模型](#61-包含模型)
    - [6.1.1 链接器错误](#611-链接器错误)
    - [6.1.2 头文件的模板](#612-头文件的模板)
* [6.2 显式实例化](#62-显式实例化)
    - [6.2.1 显式实例化的例子](#621-显式实例化的例子)
    - [6.2.2 整合包含模型和显式实例化](#622-整合包含模型和显式实例化)
* [6.3 分离模型](#63-分离模型)
    - [6.3.1 关键字export](#631-关键字export)
    - [6.3.2 分离模型的限制](#632-分离模型的限制)
    - [6.3.3 为分离模型做好准备](#633-为分离模型做好准备)
* [6.4 模板和内联](#64-模板和内联)
* [6.5 预编译头文件](#65-预编译头文件)
* [6.6 调试模板](#66-调试模板)
    - [6.6.1 理解长段的错误信息](#661-理解长段的错误信息)
    - [6.6.2 浅式实例化](#662-浅式实例化)
    - [6.6.3 长符号串](#663-长符号串)
    - [6.6.4 跟踪程序](#664-跟踪程序)
    - [6.6.5 oracles](#665-oracles)
    - [6.6.6 archetypes](#666-archetypes)
* [6.7 本章后记](#67-本章后记)
* [6.8 小结](#68-小结)

<!-- vim-markdown-toc -->



## 6.1 包含模型

### 6.1.1 链接器错误

```c++
// a.hpp
template <typename T>
void fn(T const&)
```

```c++
// a.cpp
#include "a.hpp"

template <typename T>
void fn(T const& x)
{
    ...
}
```

```c++
// main.cpp
#include "a.hpp"

int main()
{
    double d;
    fn(d);
}
```

函数模板`fn()`的定义还没有被实例化。为了使模板真正得到实例化。为了使模板真正得到实例化，编译起必须知道：应该实例化那个定义以及要给予哪个模板实参来进行实例化。这两部分信息位于分开编译的不同文件里面。因此，当我们的编译器看到`fn()`被调用，但还没有看到基于double实例化的函数定义的时候，它只是假设在别处提供了这个定义，并产生一个指向该定义的引用（让链接器利用该引用来解决这个问题）。另一方面，当编译器处理`a.cpp`的时候，它并没有指出：编译器必须基于特定实参对所包含的模板定义进行实例化。

### 6.1.2 头文件的模板

包含模型：把模板的定义也包含在声明模板的头文件里面，即让定义和声明都位于同一个头文件中。

缺点：

- 包含模型明显增加了头文件的开销；
- 非内联函数模板在调用位置并不会被扩展，而是当它们基于某种类型进行实例化后，才产生一份新的（基于该类型的）函数拷贝。因为这（产生函数拷贝）是一个自动化过程，所以在编译结束的时候，编译器可能会在不同的文件里产生两份拷贝，当链接器发现同一个函数具有两种不同的定义时，就会报告一个错误。



## 6.2 显式实例化

实例化类模板时会同时实例化它的所有类成员，而且对于每个不同的实体，在一个程序中最多只能有一个实例化体，并且也就不能有显式特化了。

### 6.2.1 显式实例化的例子

```c++
template class Stack<int>;                      // 显式实例化类模板
template Stack<int>::Stack();                   // 显式实例化类模板的成员函数
template void PrintType<double>(double const&); // 显式实例化函数模板
```

缺点：

- 必须手动跟踪每一个需要实例化的实体，因为一个程序中不允许有多份的实例化实体。

优点：

- 避免了包含庞大的头文件开销，更可以把模板定义的源文件封装起来。

### 6.2.2 整合包含模型和显式实例化



## 6.3 分离模型

### 6.3.1 关键字export

关键字export的功能使用：在一个文件里面定义模板，并在模板的定义和（非定义的）声明的前面加上关键字export。

使用模板的位置和模板定义的位置可以在两个不同的翻译单元中。

在一个预处理文件内部（就是指在一个翻译单元内部），我们只需要在第一个声明前面标记export关键字就可以了，后面的重新声明（也包括定义）会隐式地保留这个export特性。另一方面，在模板定义中提供了一个冗余的export关键字也是可取的，因为这样可以提高代码的可读性。

export关键字不能和inline关键字一起使用；如果用于模板的话，export要位于关键字template之前。

### 6.3.2 分离模型的限制

### 6.3.3 为分离模型做好准备



## 6.4 模板和内联

函数模板和内联函数都可以被定义于多个翻译单元中。通常，通过下面途径来获取这个实现：把定义放在一个头文件中，而这个头文件又被多个dot-C文件所包含(#include)。



## 6.5 预编译头文件

预编译头机制：

- 预编译头文件机制主要依赖于下面的事实：我们可以使用某种方式来组织代码，让多个文件中前面的代码都是相同的。
- 充分利用预编译头文件的关键之处在于：（尽可能地）确认许多文件开始处的相同代码的最大行数。
- 绝大多数情况下，可以用一个头文件来包含所有的标准头文件，然后对这个头文件来包含所有的标准头文件，然后其他的代码如果用到了标准库就只要引用这个头文件。
- 管理预编译头文件的一种可取方法是：对预编译头文件进行分层，即根据头文件的使用频率和稳定性来进行分层。
- 预编译头文件时要注意被宏的影响，宏能完全影响头文件的语义。所以，只预编译标准库是个比较实用而简介的主意。或者绝不使用宏。



## 6.6 调试模板

- 语法约束（syntactic constraint）：由编译器保证，如sort要求必须定义有`operator<`；
- 语义约束（semantic constraint）：由程序员保证，如sort的operator<的确定义了某种排序规则。

### 6.6.1 理解长段的错误信息

### 6.6.2 浅式实例化

通过插入没有使用的代码（哑代码）来获取这种实现，这些代码并没有其它用途，只是在实例化模板代码的高层模板实参不符号底层模板约束时，引发一个错误。

### 6.6.3 长符号串

实例化后的模板代码会产生很长的符号串。

### 6.6.4 跟踪程序

使用跟踪程序是相对比较简单和行之有效的技术，但它只能让我们对模板的特定输入和相关功能的特定行为进行跟踪。

### 6.6.5 oracles

### 6.6.6 archetypes



## 6.7 本章后记



## 6.8 小结

- 模板给原始的“编译器+链接器”模型带来挑战，因此，需要使用其它的方法来组织模板代码，这些方法是包含模型，显式实例化和分离模型。
- 在大多数情况下，你应该使用包含模型（就是说，把所有模板代码都放在头文件中）。
- 通过把模板声明代码和模板定义代码放在不同的头文件中，你可以很容易地在包含模型和显式实例化之间做出选择。
- C++标准为模板定义了一个分离的编译模型（使用关键字export）。
- 调试模板代码是具有挑战性的。
- 模板实例化可能会具有很长的名称。
- 为了充分利用预编译代码，要确认#include指示符的顺序是相同的。
