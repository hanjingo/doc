# Chapter10 实例化

<!-- vim-markdown-toc GFM -->

* [10.1 On-Demand实例化](#101-on-demand实例化)
* [10.2 延迟实例化](#102-延迟实例化)
* [10.3 C++的实例化模型](#103-c的实例化模型)
    - [10.3.1 两阶段查找](#1031-两阶段查找)
    - [10.3.2 POI](#1032-poi)
    - [10.3.3 包含模型与分离模型](#1033-包含模型与分离模型)
    - [10.3.4 跨翻译单元查找](#1034-跨翻译单元查找)
    - [10.3.5 例子](#1035-例子)
* [10.4 几种实现方案](#104-几种实现方案)
    - [10.4.1 贪婪实例化](#1041-贪婪实例化)
    - [10.4.2 询问实例化](#1042-询问实例化)
    - [10.4.3 迭代实例化](#1043-迭代实例化)
* [10.5 显式实例化](#105-显式实例化)
* [10.6 本章后记](#106-本章后记)

<!-- vim-markdown-toc -->

对于产生自模板的实体（指具体类型或函数），它们的定义已经不再局限于源代码中的单一位置。事实上，模板本身的位置，使用模板的位置，定义模板实参的位置都会对这个（产生自模板的）实体的含义产生一定的影响。

## 10.1 On-Demand实例化

on-demand实例化（隐式实例化或自动实例化）：当C++编译器遇到模板特化的使用时，它会利用所给的实参替换对应的模板参数，从而产生该模板的特化。

在使用模板（特化）的地方，编译器通常需要访问模板和某些模板成员的整个定义（也就是说，只有声明是不够的）。

C++的重载解析规则要求：如果候选函数的参数是class类型，那么该类型所对应的类就必须是可见的：

```c++
template <typename T>
class C {
    public:
        C(int); // 具有单参数的构造函数，可以被用于隐式类型转换
};

void candidate(C<double> const&);
void candidate(int) {}

int main()
{
    candidate(42); // 前面两个函数声明都可以被调用
}
```



## 10.2 延迟实例化

当隐式实例化类模板时，同时也实例化了该模板的每个成员声明，但并没有实例化相应的定义。以下情况例外：

- 如果类模板中包含了一个匿名的union，那么该union定义的成员同时也被实例化了。
- 作为实例化类模板的结果，虚函数的定义可能被实例化，但也可能还没有被实例化，这要依赖于具体的实现。



## 10.3 C++的实例化模型

模板实例化过程：根据相应的模板实体，适当地替换模板参数，从而获得一个普通类或者函数。

### 10.3.1 两阶段查找

实例化点（point of instantiation, POI）。

### 10.3.2 POI

### 10.3.3 包含模型与分离模型

使用export关键字来声明非类型模版，而在另一个翻译单元中定义该非类型模版。

### 10.3.4 跨翻译单元查找

第一阶段发生在解析模版的时候，在这个过程中，会使用普通查找规则和ADL规则对非依赖型名称进行查找。

第二阶段发生在产生POI（实例化点）的时候。在这一点上，会使用普通查找规则和ADL规则来朝着依赖型受限名称。

### 10.3.5 例子

```c++
template <typename T>
void f1(T x) {
    g1(x); // x是依赖名称，它依赖于T
    // g1(6); // 如果换成这样写，6是非依赖的，所以它应该查找不到g1。gcc正确抱错"错误：'g1'的实参不依赖模版参数，所以'g1'的声明必须可用[-fpermissive]"，VC++却通过编译并调用了后面的g1，这是不符合标准的。
}

int main() {
    f1(7);
}

void g1(int) {
    std::cout << "g1(int)" << std::endl;
}
```



## 10.4 几种实现方案

### 10.4.1 贪婪实例化

贪婪实例化假定链接器知道：特定的实体（特别是可链接的模板实例化体）可以在多个目标文件和程序库中多次出现；于是，编译器会使用某种方法对这些实体进行标记。当链接器找到多个实例的时候，它会保留其中一个实例，而抛弃所有其他的实例。

从理论上来讲，贪婪实例化具有下面几个严重的缺点：

- 编译器会在生成和优化N个实例化体上浪费时间，而最后只有一个实例化体会被保留。
- 链接器通常不会检查两个实例化体是否是一样的，因为在生成的代码中，同一个模板特化的多个实例之间中可能会出现一些细微的差异。
- 与其它解决方案相比，（最后生成的）所有目标文件的大小综合可能会更大，因为相同代码可能会生成多次。

贪婪实例化优势：

- 保留了源对象之间的原始依赖性。

### 10.4.2 询问实例化

询问实例化：维护一个数据库，程序中所有翻译单元的编译都会共享这个数据库。数据库会跟踪一些信息，然后把生成的特化和这些信息储存在数据库中。当遇到可链接实体的POI时，会根据具体的前提，从以下操作中选出一个：

- 不存在所需要的特化：在这种情况下，会发生实例化过程，然后生成的特化被放入数据库中。
- 所需的特化已经存在，但已经是过期的--因为在该特化生成之后，源代码发生了改变。这样也会再次进行实例化，并用所得的特化替换数据库中原有的特化。
- 一个不需要更新的特化已经存在于数据库中，那么就不需要进行实例化。

### 10.4.3 迭代实例化

编译器不实例化任何可链接的特化，链接器在真正需要时再调用编译器实例化出来。这种迭代的方法浪费了很多时间在编译器和链接器来回转移上，而且把错误信息延迟到了链接期。



## 10.5 显式实例化

显式实例化指示符（explicit instantiation directive）为模板特化显式地生成POI。

自动模板实例化会对创建时间产生严重的负面影响。提高创建效率的一种方法就是：在某一个位置手工实例化特定的模版特化，并且禁止在所有其它的翻译单元中进行模版的实例化。为了能够保证这种禁止，唯一可移植的方法就是：除了这个显式实例化所在的翻译单元之外，其它的翻译单元都不提供模版的定义。



## 10.6 本章后记

C++中，宏并非是能够带来意外强耦合性的唯一构造，导出（export）模型也会带来其它形式的强耦合性。

