# 第11章 模版实参演绎


<!-- vim-markdown-toc GFM -->

* [11.1 演绎的过程](#111-演绎的过程)
* [11.2 演绎的上下文](#112-演绎的上下文)
* [11.3 特殊的演绎情况](#113-特殊的演绎情况)
* [11.4 可接受的实参转型](#114-可接受的实参转型)

<!-- vim-markdown-toc -->



## 11.1 演绎的过程

如果被声明的参数是一个引用声明（即T&），那么P就是所引用的类型（即T），而A仍然是实参的类型。否则的话，P就是所声明的参数类型，而A则是实参的类型；如果这个实参的类型是数组或者函数类型，那么还会发生decay转型，转化为对应的指针类型，同时还会忽略高层次的const和volatile限定符。

对于引用参数，绑定到该参数的实参是不会进行decay的。



## 11.2 演绎的上下文

以下构造不能作为演绎的上下文：

- 受限的类型名称。例如，一个诸如`Q<T>::X`的类型名称不能被用来演绎模版参数T。
- 除了非类型参数之外，模版参数还包含其它成分的非类型表达式。



## 11.3 特殊的演绎情况

两种特殊的演绎情况：

- 在取函数模版地址的时候，会进行实参演绎并实例化：

    ```c++
    template<typename T>
    void f(T, T);
    void (*pf)(char, char) = &f;
    ```

- 与转型运算符模版一起出现的时候：

    ```c++
    struct S {
        public:
            template<typename T, int N> operator T[N]&(){...}
    };

    void f(int (&)[20]){...}
    void g(S s) {
        f(s);
    }
    ```



## 11.4 可接受的实参转型

模版演绎过程会试图找到函数模版参数的一个匹配，以使参数化类型P等同于类型A。当找不到这种匹配的时候，下面的变化是可接受的：

- 如果原来生命的参数是一个引用参数子，那么被替换的P类型可以比A类型多一个const或者volatile限定符。
- 如果A类型是指针类型或者成员指针类型，
