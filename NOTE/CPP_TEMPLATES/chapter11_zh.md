# 第11章 模版实参演绎

[TOC]



## 11.1 演绎的过程

如果被声明的参数是一个引用声明（即T&），那么P就是所引用的类型（即T），而A仍然是实参的类型。否则的话，P就是所声明的参数类型，而A则是实参的类型；如果这个实参的类型是数组或者函数类型，那么还会发生decay转型，转化为对应的指针类型，同时还会忽略高层次的const和volatile限定符。

对于引用参数，绑定到该参数的实参是不会进行decay的。



## 11.2 演绎的上下文

以下构造不能作为演绎的上下文：

- 受限的类型名称。例如，一个诸如`Q<T>::X`的类型名称不能被用来演绎模版参数T。
- 除了非类型参数之外，模版参数还包含其它成分的非类型表达式。



## 11.3 特殊的演绎情况

两种特殊的演绎情况：

- 在取函数模版地址的时候，会进行实参演绎并实例化：

    ```c++
    template<typename T>
    void f(T, T);
    void (*pf)(char, char) = &f;
    ```

- 与转型运算符模版一起出现的时候：

    ```c++
    struct S {
        public:
            template<typename T, int N> operator T[N]&(){...}
    };
    
    void f(int (&)[20]){...}
    void g(S s) {
        f(s);
    }
    ```



## 11.4 可接受的实参转型

模版演绎过程会试图找到函数模版参数的一个匹配，以使参数化类型P等同于类型A。当找不到这种匹配的时候，下面的变化是可接受的：

- 如果原来生命的参数是一个引用参数子，那么被替换的P类型可以比A类型多一个const或者volatile限定符。
- 如果A类型是指针类型或者成员指针类型，那么它可以进行限定符转型（就是说，添加const或者volatile限定符），转化为被替换的P类型。
- 当演绎过程不涉及到转型运算符模板的时候，被替换的P类型可以是A类型的基类；或者当A是指针类型时，P可以是一个指针类型，它所指向的类型是A所指向的类型的基类。



## 11.5 类模板参数

模板实参演绎只能应用于函数模板和成员函数模板，不能用于类模板。对于类模板的构造函数，也不能根据实参来演绎类模板参数。例：

```c++
template<typename T>
class S {
    public:
    	S(T b) : a(b) {}
    private:
    	T a;
};

S x(12); // 错误：不能从构造函数的调用实参12演绎类模板参数T
```



## 11.6 缺省调用实参

对于缺省调用实参而言，即使不是依赖型的，也不能用于演绎模板实参。例：

```c++
template<typename T>
void f(T x = 42){...}
int main()
{
    f<int>(); // 正确；T=int
    f();      // 错误；不能根据缺省调用实参42来演绎T
}
```



## 11.7 Barton-Nackman方法

限制的模板扩展（restricted template expansion）。

```c++
template<typename T>
class Array{
    public:
    	...
        friend bool operator==(Array<T> const &a, Array<T> const &b) {...}
}
```



## 11.8 本章后记

