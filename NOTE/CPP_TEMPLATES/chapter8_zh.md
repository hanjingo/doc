# Chapter8 深入模板基础


<!-- vim-markdown-toc GFM -->

* [8.1 参数化声明](#81-参数化声明)
    - [8.1.1 虚成员函数](#811-虚成员函数)
    - [8.1.2 模板的链接](#812-模板的链接)
    - [8.1.3 基本模板](#813-基本模板)
* [8.2 模板参数](#82-模板参数)
    - [8.2.1 类型参数](#821-类型参数)
    - [8.2.2 非类型参数](#822-非类型参数)
    - [8,2.3 模板的模板参数](#823-模板的模板参数)
    - [8.2.4 缺省模板实参](#824-缺省模板实参)
* [8.3 模板实参](#83-模板实参)
    - [8.3.1 函数模板实参](#831-函数模板实参)
    - [8.3.2 类型实参](#832-类型实参)
    - [8.3.3 非类型实参](#833-非类型实参)
    - [8.3.4 模板的模板实参](#834-模板的模板实参)
    - [8.3.5 实参的等价性](#835-实参的等价性)
* [8.4 友元](#84-友元)
    - [8.4.1 友元函数](#841-友元函数)
    - [8.4.2 友元模板](#842-友元模板)

<!-- vim-markdown-toc -->



## 8.1 参数化声明

### 8.1.1 虚成员函数

成员函数模板不能被声明为虚函数，这是一种需要强制执行的限制，因为成员函数模板的使用方式在本质上与虚函数的实现方式是矛盾的。

成员函数的模板的实例化个数，要等到整个程序都翻译完毕胡才知道到底有多少个。而虚函数实现的机制要求vtable的个数必须在编译这个类开始时就完全固定下来。

### 8.1.2 模板的链接

每个模板都必须有一个名字，而且在它所属的作用域下，该名字必须是唯一的；除非函数模板可以被重载。特别是，类模板不能和另一个实体共享一个名称。

```c++
int c;
class c; // 正确：类名称和非类名称位于不同的名字空间

int x;
template <typename T>
class x; // 错误：与变量x冲突

struct s;
template <typename T>
class s; // 错误：与struct s冲突
```

模板名字是具有链接的，但他们不能具有C链接。

模板在C++中通常具有外部链接，除非使用static修饰它。

### 8.1.3 基本模板

在同一对尖括号内部，位于后面的模板参数声明可以引用前面的模板参数名称（但前面的显然不可以引用后面的）。

```c++
template <typename T> class Box;    // 正确

template <typename T> class Box<T>; // 错误

template <typename T> void translate(T*);    // 正确

template <typename T> void translate<T>(T*); // 错误
```



## 8.2 模板参数

现今存在3种模板参数：

- 类型参数；
- 非类型参数；
- 模板的模板参数。

### 8.2.1 类型参数

### 8.2.2 非类型参数

非类型参数表示的是：在编译期或链接期可以确定的常量。这种参数的类型必须是下面的一种：

- 整型或者枚举类型；
- 指针类型（包含普通对象的指针，函数指针，指向成员的指针）；
- 引用类型（指向对象或者指向函数的引用都是允许的）。

令人惊讶的是，某些情况下，非模板参数的声明也可以使用关键字typename：

```c++
template <typename T,                  // 类型参数
         typename T::Allocator *alloc> // 非类型参数
class List;
```

**注意1:非类型模板参数的声明和变量的声明很相似，但他们不能具有static, mutable等修饰符，只能具有const和volatile限定符。如果这两个限定符限定的如果是最外围的参数类型，编译器会忽略它们。**

**注意2:非类型模板参数只能是右值；它们不能被取地址，也不能被赋值。**

### 8,2.3 模板的模板参数

### 8.2.4 缺省模板实参

与缺省的函数调用参数的约束一样：对于任一个模板参数，只有在之后的模板参数都提供了缺省实参的前提下，才能具有缺省模板实参。后面的缺省值通常是在同个模板声明中提供的，但也可以在前面的模板声明中提供。

```c++
template <typename T=int>
T f() {
    return T();
}

cout << f() << endl;
```



## 8.3 模板实参

模板实参是指：在实例化模板时，用来替换模板参数的值。我们可以使用下面几种机制来确定这些值：

- 显式模板实参：紧跟在模板名称后面，在一对尖括号内部的显式模板实参值。所组成的整个实体称为template-id。
- 注入式（injected）类名称：对于具有模板参数$P_1, P_2, ...$的类模板X，在它的作用域中，模板名称（即X）等同于`template-id: X<P_1, P_2, ...>`。
- 缺省模板实参：如果提供缺省模板实参的话，在类模板的实例中就可以省略显式模板实参。
- 实参演绎：对于不是显式指定的函数模板实参，可以在函数的调用语句中，根据函数调用实参的类型来演绎出函数模板实参。

### 8.3.1 函数模板实参

函数的实参类型可以通过实参演绎来得到，如果所有的模板实参都可以通过演绎得到，那么函数模板名称后面就不需要指定尖括号。

由于函数模板可以被重载，所以对于函数模板而言，显式的提供所有的实参并不足以标识每一个函数（有时提供了所有的实参也只能标识许多函数组成的集合）：

```c++
template <typename Func, typename T>
void apply(Func f, T x) {
    f(x);
}

template <typename T> void multi(T t) {
    cout << 1 << ": " << t << endl;
}

template <typename T> void multi(T *t) {
    cout << 2 << ": " << *t << endl;
}

int i = 3;
apply(&multi<int>, i); // 这里应该产生二义性
```

SFINAE(替换失败并非错误)原则：SFINAE是令函数模板可以重载的重要因素，SFINAE对于C++模板至关重要。

允许试图创建无效的类型，但并不允许试图计算无效的表达式。

### 8.3.2 类型实参

我们平时用的大多数类型都可以被用作模板的类型实参，但有2种情况例外：

- 局部类和局部枚举（指在函数定义内部声明的类型）；
    注意区分局部类和内部类：

    `局部类` 指在函数定义内声明的类；

    `内部类` 指在类定义内声明的类。

- 未命令的class类型和枚举类型。

### 8.3.3 非类型实参

非类型模板实参是那些替换非类型参数的值，这个值必须是以下中的一种：

- 某一个具有正确类型的非类型模板参数。
- 一个编译期整型常值（或枚举值）。
- 前面有单目运算符`&`（即取地址）的外部变量或者函数的名称。
- 对于引用类型的非类型模板参数，前面没有`&`运算符的外部变量和外部函数也是可取的。
- 一个指向成员的指针常量（pointer-to-member constant）；换句话说，类似`&C::m`的表达式，其中C是一个class类型，m是一个非静态成员（成员变量或者函数）。

模板实参的一个普遍约束是：在程序创建的时候，编译器或者链接器要能够确定实参的值。

有些常量不能作为有效的非类型实参：
- 空指针常量；
- 浮点型值；
- 字符串（可以用std::string完美解决）。

### 8.3.4 模板的模板实参

模板的模板实参必须精确匹配：在匹配过程中，“模板的模板实参”的缺省模板实参将不会被考虑，但是“模板的模板参数”的缺省实参还是有效的（注意区分实参和参数）。

```c++
template <typename T,
    template <typename ELEM,
    typename ALLOC = std::allocator<ELEM>>
    class CONT>

class Stack{
    public:
        Stack(){}
        Stack(Stack<T, CONT> const &);
        ~Stack(){}
        Stack<T, CONT> operator=(Stack<T, CONT> const &);
    private:
        CONT<T> elems;
};

Stack<int, vector> stack;
```

### 8.3.5 实参的等价性

当每个对应的参数都相等时，就称为这两组模板是相等的：

```c++
template <typename T, int I>
class Mix{};
typedef int Integer;
Max<int, 3*3> p1;
Max<Integer, 4+5> p2; // 等价于p1
```

- 从成员函数模板产生的函数永远不会改写一个虚函数；
- 从构造函数模板产生的构造函数一定不会是缺省的拷贝构造函数。



## 8.4 友元

- 友元声明可能是某个实体的唯一声明；
- 友元函数的声明可以是一个定义。

### 8.4.1 友元函数

**注意1:不能在友元声明中定义一个模板实例。**

如果名称后面没有紧跟一对尖括号，那么只有在下面两种情况下是合法的：

1. 如果名称不是受限的；
2. 如果名称是受限的（就是说前面有双冒号::），那么该名称必须引用一个在此之前声明的函数或者函数模板。

```c++
void multiply(void*); // 普通函数
template<typename T>  // 函数模板
void multiply(T);
class Comrades {
   friend void multiply(int){}    // 定义了一个新函数::multiply(int)
   friend void ::multiply(void*); // 受限名称，则是引用先前定义的普通函数
   friend void ::multiply(int);   // 引用template的一个实体
   friend void ::multiply<double*>(double*); // 带尖括号，一定是一个模板的实例，而且此时编译器必须见到了此template
   friend void ::error(){} // ERROR：受限的名称，一定是对已经存在的名称的引用
};
```

一般来说必须在模板内部定义的友元函数类型定义中，包含了类模板的模板参数，这样就不会生成两个完全相同的函数，就不会违反ODR了。

### 8.4.2 友元模板

让模板的所有实例都成为友元，这就需要声明友元模板。

```c++
class Manager{
    template<typename T>
    friend int ticket(){}
};
```
