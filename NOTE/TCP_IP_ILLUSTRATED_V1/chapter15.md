# TCP数据流与窗口管理

[TOC]



## Nagle算法

`Nagle算法` 当一个TCP连接中有在传数据（即那些已发送但还未经确认的数据），小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK。并且，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。此算法迫使TCP遵循停等（stop-and-wait）规程--只有等接收到所有在传数据的ACK后才能继续发送。此算法的精妙之处在于它实现了自时钟（self-clocking）控制：ACK返回越快，数据传输也越快。在相对高延迟的广域网中，更需要减少微型报的数目，该算法使得单位时间内发送的报文段数目更少。也就是说，RTT控制着发包速率。

例，同一环境下禁用/使用Nagle算法的TCP连接情况：

![15_6](res/15_6.png)

在启用Nagle算法的情况下，在任一时刻最多只有一个包在传，这样可以减少小包数目，但同时也增大了传输时延；

### 延时ACK与Nagle算法结合

ACK与Nagle算法的结合导致了某种程度的`死锁`（两端互相等待对方做出行动），在死锁期间整个传输连接处于空闲状态，使性能变差；这种死锁并不是永久的，在延时ACK计时器超时后死锁会解除。

例，Nagle算法与延时ACK的交互，形成一个短暂的死锁：

![15_7](res/15_7.png)

### 禁用Nagle算法

对于一些延时敏感的应用，需要禁用Nagle算法，禁用方法如下：

1. `Berkeley套接字` 设置TCP_NODELAY选项；
2. `Windows系统` 设置注册表`HKLM\so盯WARE\Micr ゚S ゚ft\MsMQ\parameters \TCPNoDelay`的值为1；



## 流量控制与窗口管理

### 滑动窗口

每个TCP活动连接维护以下窗口：

- 发送窗口结构（send window structure）
- 接收窗口结构（receive window structure）

例，提供窗口：

![15_9](res/15_9.png)

- `提供窗口` 由接收端通告的窗口
- `可用窗口` 它可以立即发送的数据量，其值=$SND.UNA + SND.WND - SND.NXT$

TCP发送端滑动窗口结构记录了已确认，在传以及还未传的数据的序列号，提供窗口的大小由接收端返回的ACK中的窗口大小字段控制；

例，接收窗口结构：

![15_10](res/15_10.png)

- 

TCP接收端滑动窗口结构帮助了解其下次应接收的数据序列号，若接收到的数据序列号在窗口内，则可以存储，否则丢弃；

窗口的左右边界运动：

- `关闭（close）` 窗口左边界右移，当已发送数据得到ACK确认时，窗口会减少。
- `打开（open）` 窗口右边界右移，使得可发送数据量增大，当已确认数据得到处理，接收端可用缓存变大，窗口也随之变大。
- `收缩（shrink）` 窗口右边界左移。

### 零窗口与TCP持续计时器

