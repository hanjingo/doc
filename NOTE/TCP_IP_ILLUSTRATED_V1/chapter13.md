# 第十三章 TCP 连接管理

[TOC]



## TCP连接的建立与终止

![13_1](res/13_1.png)

*一个普通TCP连接的建立与终止。通常，由客户端负责发起一个三次握手过程。在该过程中，客户端与服务器利用SYN报文段交换彼此的初始序列号（包括客户端的初始序列号和服务器的初始序列号）。在通信双方都发送了一个FIN数据包并收到来自对方的相应的确认数据包后，该连接终止*

- ISN (Initial Sequence Number, 初始序列号)

一个普通TCP连接的建立和终止，通常由客户端负责发起一个三次握手过程；在该过程中，客户端与服务器利用SYN豹纹端交换彼此的初始序列号（包括客户端的初始序列号和服务器的初始序列号）；在通信双方都发送了一个FIN数据包并收到来自对方的相应的确认数据包后，该连接终止；

### 建立连接

1. 客户端发送一个SYN报文段（设置SYN字段），并指明想要连接的端口号和初始序列号ISN(c)；
2. 服务端发送SYN报文段，包含初始序列号ISN(s)，ACK = ISN(c)+1；
3. 发送ACK = ISN(s)+1 报文；

### 关闭连接

1. 客户端发送一个FIN报文段，包括：序列号（K），一个ACK段；用于确认对方最近一次发来的的数据（L）。
2. 服务端将ACK设置为K+1，以表明它已经成功接收到客户端发送的FIN报文段。
3. 服务端发送自己的FIN，序列号为L，以表明它以成功发送完数据。
4. 客户端发送一个ACK用于确认上一个FIN。

### TCP半关闭

![13_2](res/13_2.png)

*在TCP半关闭操作中，连接的一个方向被关闭，而另一个方向仍在传输数据直到它被关闭为止；（很少有应用程序使用这一特性）*

### 同时打开与关闭

![13-3](res/13-3.png)

*在同时打开中交换的报文段。与正常的连接建立过程相比，需要增加一个报文段。数据报的SYN位将置位直到接收到一个ACK数据包为止*

![13-4](res/13-4.png)

*在同时关闭中交换的报文段。与正常关闭相似，指示报文段的顺序是交叉的*

### 初始序列号

TCP报文段伪造：选择合适的序列号，IP地址以及端口号，那么任何人都能伪造出一个TCP报文段，从而打断TCP的正常连接`[RFC5961]`。

Linux系统采用基于时钟的方案，并且针对每一个连接为时钟设置随机的偏移量，来设置初始序列号，从而防止TCP报文段被伪造。具体参考：`CA-2001-09[CERTISN]`。



## TCP选项

TCP选项数值，超过40个字节用于保存选项

| 种类 | 长度 | 名称           | 参考       | 描述与目的                       |
| ---- | ---- | -------------- | ---------- | -------------------------------- |
| 0    | 1    | EOL            | [RFC0793]  | 选项列表结束                     |
| 1    | 1    | NOP            | [RFC0793]  | 无操作（用于填充）               |
| 2    | 4    | MSS            | [RFC0793]  | 最大段大小                       |
| 3    | 3    | WSOPT          | [RFC01323] | 窗口缩放因子（窗口左移量）       |
| 4    | 2    | SACK-Permitted | [RFC02018] | 发送者支持SACK选项               |
| 5    | 可变 | SACK           | [RFC02018] | SACK阻塞（接收到乱序数据）       |
| 8    | 10   | TSOPT          | [RFC01323] | 时间戳选项                       |
| 28   | 4    | UTO            | [RFC05482] | 用户超时（一段空闲时间后的终止） |
| 29   | 可变 | TCP-AO         | [RFC05925] | 认证选项（使用多种算法）         |
| 253  | 可变 | Experimental   | [RFC04727] | 保留供实验所用                   |
| 254  | 可变 | Experimental   | [RFC04727] | 保留供实验所用                   |

- MSS

  TCP协议所允许的从对方接收到的最大报文段，不包括TCP头部和IP头部。

- SACK

  当收到乱序数据时，能提供一个SACK选项来描述这些乱序的数据，从而帮助对方有效的进行重传。

- WSOPT

  该选项可以有效的改变TCP窗口数值，通过将窗口字段值左移来成比例的扩大窗口数值；窗口数值的扩大公式为：$65535 \times 2^{S}$​​​，其中S为比例因子，取值范围[0, 14]；窗口数值最大为$65536 \times 2^{14}$​，约等于1GB。

- TSPOT

  时间戳选项要求发送方在每一个报文段中添加2个4字节的时间戳数值，接收方将会在确认中反映这些数值，允许发送方针对每一个接收到的ACK估算TCP连接的往返时间。

  防回绕序列号（Protection Against Wrapped Sequence numbers，PAWS），为接受者提供了避免接收旧报文段与判断报文段正确性的方法。

  TCP时间戳选项通过提供一个额外的32位有效序列号空间清除了具有相同序列号的报文段之间的二义性：

  | 时间 | 发送字节数 | 发送序列号 | 发送时间戳 | 接收                         |
  | ---- | ---------- | ---------- | ---------- | ---------------------------- |
  | A    | 0G:1G      | 0G:1G      | 1          | 完好                         |
  | B    | 1G:2G      | 1G:2G      | 2          | 完好，但一个报文段丢失并重传 |
  | C    | 2G:3G      | 2G:3G      | 3          | 完好                         |
  | D    | 3G:4G      | 3G:4G      | 4          | 完好                         |
  | E    | 4G:5G      | 0G:1G      | 5          | 完好                         |
  | F    | 5G:6G      | 1G:2G      | 6          | 完好，但重传的报文段重新出现 |

- UTO

  该选项是一个相对较新的TCP的功能，用户超时数值（USER_TIMEOUT）指明了TCP发送者在确认对方未能成功接收数据之前愿意等待该数据ACK确认时间。USER_TIMEOUT的计算方法如下：

  `USER_TIMEOUT = min(U_LIMIT, max(ADV_UTO, REMOTE_UTO, L_LIMIT))`

  - `U_LIMIT` 本地系统对用户超时选项设定的数值**上边界**
  - `L_LIMIT` 本地系统对用户超时选项设定的数值**下边界**
  - `ADV_UTO` 本端告知远端通信方的用户超时选项数值
  - `REMOTE_UTO` 远端通信方告知的用户超时选项数值

- TCP-AO

  (TCP Authentication Option，TCP-AO)，用于增强连接的安全性；使用一种加密散列算法以及TCP连接双方共同维护的一个秘密值来认证每一个报文段。



## TCP的路径最大传输单元发现

TCP常规的路径最大传输单元发现过程如下：在一个连接建立时，TCP使用对外接口的最大传输单元的最小值，或者根据通信对方声明的最大段大小来选择发送方的最大段大小（SMSS）。

最大传输单元如果没有声明，默认536字节。



## TCP状态转换

### TCP状态转换图

![13-8](res/13-8.png)

*TCP状态转换图（也称作有限状态机）。箭头表示因报文段传输，接收以及计时器超时而引发的状态转化。粗箭头表示典型的客户端的行为，虚线箭头表示典型的服务器行为。粗体指令（例如 open，close）是应用程序执行的操作*

### 连接的建立与终止

![13-9](res/13-9.png)

*与正常连接的建立与终止相关的TCP状态*

### TIME_WAIT状态

TIME_WAIT状态也称为`2MSL等待状态`或`加倍等待`，TCP将会等待两倍于最大段生存期（Maximum Segment Lifetime, MSL）的时间；它代表任何报文段在被丢弃前在网络中被允许存在的最长时间，常见的值为：30秒，1分钟，2分钟...。

2MSL的值可以被修改，其值的保存位置如下：

- linux

   `net.ipv4.tcp_fin_timeout`。

- windows

  `HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\TcpTimeWaitDelay`。

影响2MSL等待状态的因素：

1. 当TCP执行一个主动关闭并发送最终的ACK时，连接必须处于TIME_WAIT状态并持续两倍于最大生存期的时间。这样就能让TCP重新发送最终的ACK以避免出现丢失的情况。重新发送最终的ACK并不是因为TCP重传了ACK（他们并不消耗序列号，也不会被TCP重传），而是因为通信另一方重传了它的FIN（它消耗一个序列号）。

2. 当TCP处于等待状态时，通信双方将该连接（客户端IP地址，客户端端口号，服务器IP地址，服务器端口号）定义为不可重新使用。

   只有当2MSL等待结束时，或一条新链接使用的初始序列号超过了连接之前的实例所使用的最高序列号时，或者允许使用时间戳选项来区分之前连接实例的报文段以避免混淆时，这条连接才能被再次使用。

有许多机制可以绕开2MSL限制，如：`SO_REUSEADDR`套接字选项...

2MSL的作用：

1. 在本地与外地的IP地址，端口号都相同的情况下，2MSL状态能够防止新的连接将前一个连接的延迟报文段解释成自身数据。

**静默时间**，[RFC0793]指出，在崩溃或者重启后TCP协议应当在创建新的连接之前等待相当于一个MSL的时间，该段时间被称为*静默时间*。

### FIN_WAIT_2状态

在FIN_WAIT_2状态，某TCP通信端已发送一个FIN并已得到另一端的确认，除非出现半关闭的情况，否则该TCP端将会等待另一端的应用程序识别出自己已接收到一个文件末尾的通知并关闭这一端引起发送FIN的连接。只有当应用程序完成了这一关闭操作（它的FIN已经被接收），正在关闭的TCP连接才会从FIN_WAIT_2状态转移至TIME_WAIT状态。这意味着连接的一端能够依然永远保持这种状态。另一端也会依然处于CLOSE_WAIT状态，并且能永远维持这一状态直到应用程序决定宣布他的关闭。

### 同时打开与关闭的转换

TODO



## 重置报文段

### 针对不存在端口的连接请求

- UDP协议

  当一个数据报到达一个不能使用的的目的端口时就会生成一个ICMP目的地不可达（端口不可达）的消息；

- TCP协议

  使用重置报文段；

### 终止一条连接

- 有序释放

  由通信一方发送一个FIN，因为FIN是在之前所有排队数据都已发送后才被发送出去，通常不会出现丢失数据的情况；

- 终止释放

  通过发送一个重置报文段替代FIN来终止一条连接；

终止一条连接可以为应用程序提供以下特性：

- 任何排队的数据都将被抛弃，一个重置报文段会被立即发送出去；
- 重置报文段的接收方会说明通信另一端采用了终止的方式而不是一次正常关闭；

套接字API通过将套接字选项（SO_LINGER）的数值设置为0来实现以上特性；

例，使用重置报文段（RST）代替FIN报文段来终止一条连接：

```sh
he@hes-MacBook-Air ~ % sudo tcpdump -vvv -s 1500 tcp
Password:
tcpdump: data link type PKTAP
tcpdump: listening on pktap, link-type PKTAP (Apple DLT_PKTAP), capture size 1500 bytes
00:14:23.419721 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51009 > 5.28.195.141.https: Flags [S], cksum 0x3610 (correct), seq 1633944638, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1354362333 ecr 0,sackOK,eol], length 0
00:14:24.420380 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51009 > 5.28.195.141.https: Flags [S], cksum 0x3228 (correct), seq 1633944638, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1354363333 ecr 0,sackOK,eol], length 0
00:14:25.420698 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51009 > 5.28.195.141.https: Flags [S], cksum 0x2e3f (correct), seq 1633944638, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1354364334 ecr 0,sackOK,eol], length 0
00:14:25.971861 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51010 > 5.28.195.141.https: Flags [S], cksum 0x629c (correct), seq 1954842719, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1940260642 ecr 0,sackOK,eol], length 0
00:14:26.421465 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51009 > 5.28.195.141.https: Flags [S], cksum 0x2a56 (correct), seq 1633944638, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1354365335 ecr 0,sackOK,eol], length 0
00:14:26.972734 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51010 > 5.28.195.141.https: Flags [S], cksum 0x5eb3 (correct), seq 1954842719, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1940261643 ecr 0,sackOK,eol], length 0
00:14:27.973930 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51010 > 5.28.195.141.https: Flags [S], cksum 0x5aca (correct), seq 1954842719, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1940262644 ecr 0,sackOK,eol], length 0
00:14:28.422258 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51009 > 5.28.195.141.https: Flags [S], cksum 0x2286 (correct), seq 1633944638, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1354367335 ecr 0,sackOK,eol], length 0
00:14:28.975535 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51010 > 5.28.195.141.https: Flags [S], cksum 0x56e0 (correct), seq 1954842719, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1940263646 ecr 0,sackOK,eol], length 0
00:14:29.976491 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51010 > 5.28.195.141.https: Flags [S], cksum 0x52f7 (correct), seq 1954842719, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1940264647 ecr 0,sackOK,eol], length 0
00:14:30.977489 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.10.102.51010 > 5.28.195.141.https: Flags [S], cksum 0x4f0e (correct), seq 1954842719, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 1940265648 ecr 0,sackOK,eol], length 0
00:14:31.382322 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 779)
```

**注意：重置报文段不会令通信另一端作出任何响应（它不会被确认）；接收重置报文段的一端会终止连接并通知应用程序当前连接已被重置，这样会造成“连接被另一端重置”的错误提示或类似信息；**

### 半开连接

如果在未告知另一端的情况下通信的一端关闭或终止连接，那么就认为该条TCP连接处于`半开状态`；

### 时间等待错误

设计`TIME_WAIT`状态的目的是允许任何受制于一条关闭连接的数据报被丢弃；

`时间等待错误（TIME-WAIT Assassination, TWA）` 如果在`TIME_WAIT`状态下接收到来自于这条连接的一些报文段，或是更加特殊的重置报文段，它将会被破坏；

![13-10](res/13-10.png)

一个重置报文段能“破坏” TIME_WAIT状态并强制连接提前关闭。目前有很多方法来阻止这一问题，其中包括在处于TIME_WAIT状态时忽略重置报文段*



## TCP服务器选项

### TCP端口号

TCP依靠4元组多路分解（demultiplex）了获得的报文段，目的IP地址与目的端口号，源IP地址与源端口号，这4元组共同构成了本地与外地节点。TCP协议不能仅仅根据目的端口来决定哪个进程该得到接收的报文段；处于`LISTEN`状态并接收进入的连接请求；处于`ESTABLISHED`状态的节点不能接收SYN报文段，而处于LISTEN状态的节点则不能接收数据段；

### 限制本地IP地址

例，限制使用到达本地IPv4地址的连接：

```sh
sock -s 10.0.0.1 8888
```

### 限制外部节点

可用于TCP服务器的地址与端口号绑定选项：

| 本地地址         | 外部地址               | 受限于       | 说明                                      |
| ---------------- | ---------------------- | ------------ | ----------------------------------------- |
| `local_IP.lport` | `foraddr.foreign_port` | 一个客户端   | 通常不支持                                |
| `local_IP.lport` | `*.*`                  | 一个本地节点 | 不常见（用于DNS服务器）                   |
| `*.local_port`   | `*.*`                  | 一个本地端口 | 最常见，多地址族（IPv4/IPv6）可能会被支持 |

### 进入连接队列

在linux中，限制完全形成的等待处理的连接数目规则如下：

1. 当一个联结请求到达（即，SYN报文段），将会检查系统范围的参数`net.ipv4.tcp_max_syn_backlog`（默认1000），如果处于`SYN_RCVD`状态的连接数目超过这一阈值，进入的连接将会被拒绝；
2. 每一个处于侦听状态下的节点都拥有一个固定长度的连接队列，其中的连接已经被TCP完全接受（即三次握手已经完成），但未被应用程序接受；应用程序会对这一队列做出限制，通常称为`未完成连接（backlog）`；`backlog`的数目必须在0与一个系统指定的最大值之间，该最大值称为`net.core.somaxconn(默认128)`；
3. 如果侦听节点的队列中仍有空间分配给新的连接，TCP模块会应答SYN并完成连接；直到接收到三次握手中的第3个报文段之后，与侦听节点相关的应用程序才会知道新的连接；当客户端的主动打开操作顺利完成之后，客户端可能会认为服务器已经准备好接收数据，然而服务器上的应用程序此时可能还未收到关于新连接的通知；如果这种情况发生服务器的TCP模块将会把到来的数据存入队列中；
4. 如果队列中已没有足够的空间分配给新的连接，TCP将会延迟对SYN作出响应，从而给应用程序一个跟上节奏的机会（linux在这方面比较特别，它坚持在能力允许的范围内不忽略进入的连接，如果系统控制变量`net.ipv4.tcp_abort_on_`已被设定，新进入的连接会被重置报文段重新置位）；



## 与TCP连接管理相关的攻击

`SYN泛洪-TCP拒绝攻击`：恶意客户端产生一系列TCP连接尝试（SYN报文段），并将它们发送给一台服务器，他们通常采用“伪造”的源IP地址；服务器会为每一条连接分配一定数量的连接资源，由于连接尚未完全建立，服务器为了维护大量的半打开连接会在耗尽自身内存后拒绝为后续的合法连接请求服务；

`伪造ICMP PTB攻击`：伪造一个ICMP PTB消息，该消息包含了一个非常小的MTU值，这样就迫使受害的TCP尝试采用非常小的数据包来填充数据，从而大大降低了它的性能；

`序列号攻击`：破坏现有的TCP连接，甚至将其劫持（hijacking）；这一类攻击通常包含的第一步是使两个之前正在通信的TCP节点“失去同步”，这样它们将使用不正确的序列号；

`欺骗攻击`：TCP报文段由攻击者精心定制，目的在于破坏或改变现有的TCP连接的行为；攻击者生成一个伪造的重置报文段并将其发送给一个TCP通信节点，假定与连接相关的4元组以及校验和都是正确的，序列号也处于正确的范围，这样就会造成连接的任意一端失败；

`SYN cookies`：用于解决`SYN泛红问题`，当一个SYN到达时，这条连接存储的大部分信息都会被编码并保存在`SYN+ACK`报文段的序列号字段；采用`SYN cookies`的目标主机不需要为进入的连接请求分配任何存储资源--只有当`SYN+ACK`报文段本身被确认后（并且已返回初始序列号）才会分配真正的内存；在这种情况下，所有重要的连接参数都能够重新获得，同时连接也能够被设置为`ESTABLISHED`状态；

