# 第四章 Schema与数据类型优化

[TOC]



## 选择优化的数据类型

以下简单的原则有助于选择正确的数据类型进行优化：

- 更小数据类型通常更快
- 简单数据类型的操作通常需要更少的CPU周期
- 尽量避免NULL

SIGNED和UNSIGNED使用相同的存储空间，并具有相同的性能；但是UNSIGNED非负整数的范围上限比SIGNED大一倍。

### 整数类型

| 类型      | 长度(bit) | 描述                                |
| --------- | --------- | ----------------------------------- |
| TINYINT   | 8         | 存储范围$[-2^{7}, 2^{7}-1]$的整数   |
| SMALLINT  | 16        | 存储范围$[-2^{15}, 2^{15}-1]$的整数 |
| MEDIUMINT | 24        | 存储范围$[-2^{23}, 2^{23}-1]$的整数 |
| INT       | 32        | 存储范围$[-2^{31}, 2^{31}-1]$的整数 |
| BIGINT    | 64        | 存储范围$[-2^{63}, 2^{63}-1]$的整数 |

### 实数类型

| 类型    | 长度(bit) | 描述             | 适用场景         |
| ------- | --------- | ---------------- | ---------------- |
| FLOAT   | 32        | 标准浮点型       |                  |
| DOUBLE  | 64        | 标准浮点型       |                  |
| DECIMAL | 变长      | 允许最多65个数字 | - 对精度要求较高 |

### 字符串类型

| 类型    | 长度() | 描述                                                         | 适用场景                                                     |
| ------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| VARCHAR |        | 存储**可变长字符串**，在UPDATE时可能使行变得比原来更长；     | - 字符串列的最大长度比平均长度大很多；<br>- 列的更新很少，碎片不是问题；<br>- 使用了像UTF-8这样的复杂字符集，每个字符都使用不同的字节数进行存储； |
| CHAR    |        | 存储**定长字符串**，根据字符串长度分配足够的空间             | - 短的字符串；<br>- 所有的字符串的长度都接近；               |
| BLOB    |        | 采用二进制方式存储字符串                                     | - 非常大的数据                                               |
| TEXT    |        | 采用字符方式存储字符串                                       | - 非常大的数据                                               |
| ENUM    |        | 使用枚举类型代替常用的字符串类型来把一些不重复的字符串存储成一个预定义的集合，MySQL会根据列表值的数量压缩 | - 字符串列表是固定的，不会修改的                             |

### 日期和时间类型

| 类型      | 长度(字节) | 描述                                               | 适用场景           |
| --------- | ---------- | -------------------------------------------------- | ------------------ |
| DATETIME  |            | 精度为秒，存储[1001, 9999]年时间                   | - 大范围的时间长度 |
| TIMESTAMP | 4          | 精度为秒，存储[1970, 2038]年时间；效率高于DATETIME | - 大部分场景       |

### 位数据类型

| 类型 | 长度(bit) | 描述                                                         | 适用场景   |
| ---- | --------- | ------------------------------------------------------------ | ---------- |
| BIT  | [0, 64]   | 存储1个或多个true/false值，慎用BIT类型，可以用CHAR(0)或TINYINT代替 | - 避免使用 |

### 选择标识符(identifier)

| 类型     | 长度 | 描述                         | 适用场景           |
| -------- | ---- | ---------------------------- | ------------------ |
| 整数     |      | 很快且可以使用AUTO_INCREMENT | - 标识列的最好选择 |
| ENUM/SET |      | 适合存储固定信息             | - 避免使用         |
| 字符串   |      | 慢且消耗存储空间             | - 避免使用         |

### 特殊类型数据



## MySQL schema设计中的陷阱

- `太多的列`

  太多列会导致CPU占用过高。

- `太多的关联`

  MySQL限制了每个关联操作最多只能有61张表。

- `过度使用枚举`

  ```sql
  CREATE TABLE ... (
  	country enum('', '0', '1', '2', ..., '31') # 非常凌乱
  ```

- `SET容易导致混乱`

  ```sql
  CREATE TABLE ...(
    is_default set('Y', 'N') NOT NULL default 'N' # 这里最好用枚举代替
  ```

- `过度使用NULL`

  尽量避免使用NULL，可以用0，特殊值或空字符串代替。

  ```sql
  CREATE TABLE ... (
    dt DATETIME NOT NULL DEFAULT '0000-00-00 00:00:00'
  ```



## 范式和反范式

### 范式的优点和缺点

| 优点                                                         | 缺点         |
| ------------------------------------------------------------ | ------------ |
| - 范式化的更新操作通常比反范式要快；<br>- 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据；<br>- 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快；<br>- 很少有多余的数据意味着检索列表数据时更少需要`DISTINCT`或者`GROUP BY`语句。 | - 需要关联。 |

### 反范式的优点和缺点

| 优点                                                         | 缺点 |
| ------------------------------------------------------------ | ---- |
| - 反范式化的schema所有数据都在一张表中，可以很好避免关联；<br>- 当数据比内存大时，全表扫描比扫描快，因为这样避免了随机I/O； |      |

### 混用范式化和反范式化



## 缓存表和汇总表

`缓存表` 存储那些可以比较简单地从schema其他表获取数据的表。

`汇总表` 存储使用GROUP BY语句聚合数据的表。

### 物化视图

物化视图实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。

### 计数器表

例，槽型的计数器表：

```sql
CREATE TABLE hit_counter (
	slot tinyint unsigned not null primary key,
  cnt int unsigned not null
) ENGINE = InnoDB
```

随机更新数据：

```sql
UPDATE hit_counter SET cnt = cnt + 1 WHERE slot = RAND() * 100;
```



## 加快ALTER TABLE操作的速度

ALTER TABLE操作的性能对大表来说是个大问题，并且ALTER TABLE操作会导致MySQL服务中断。

解决上述问题的方法有以下几种：

1. 先在不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换；
2. 使用“影子拷贝”，用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表；
3. 通过修改表的`.frm`文件来更新列的默认值，从而避免表的重建。

### 只修改.frm文件

下面这些操作是又可能不需要重建表的：

- 移除（不是增加）一个列的AUTO_INCREMENT属性；
- 增加，移除或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字串值。

为表结构创建一个新的`.frm`文件步骤：

1. 创建一张有相同结构的空表，并进行所需要的修改；
2. 执行`FLUSH TABLES WItH READ LOCK`。这将会关闭所有正在使用的表，并且禁止任何表被打开；
3. 交换`.frm`文件；
4. 执行`UNLOCK TABLES`来释放读锁。

例：

1. 创建空表`sakila.film_new`

   ```sql
   CREATE TABLE sakila.film_new LIKE sakila.film;
   ALTER TABLE sakila.film_new MODIFY COLUMN rating ENUM('G', 'PG', 'PG-13', 'R', 'NC-17', 'PG-14') DEFAULT 'G';
   FLUSH TABLES WITH READ LOCK;
   ```

2. 交换`.frm`文件

   ```sh
   mv film.frm film_tmp.frm
   mv film_new.frm film.frm
   mv film_tmp.frm film_new.frm
   ```

3. 解锁表

   ```sql
   UNLOCK TABLES;
   ```

4. 查看表结构

   ```sql
   SHOW COLUMNS FROM sakila.film LIKE 'rating'\G
   ```

5. 删除辅助表

   ```sql
   DROP TABLE sakila.film_new;
   ```

### 快速创建MyISAM索引

为了高效地载入数据到MyISAM表（对唯一索引无效），有一个常用的技巧是先禁用索引，载入数据，然后再重新启用索引，将索引的构建工作推迟到数据完全载入后：

```sql
ALTER TABLE test.load_data DISABLE KEYS;
... 载入数据
ALTER TABLE test.load_data ENABLE KEYS;
```



## 总结

- 尽量避免过度设计，例如会导致