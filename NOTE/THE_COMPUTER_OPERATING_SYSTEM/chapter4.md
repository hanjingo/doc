# 第四章 存储器管理
## 存储器分层
1. cpu： 寄存器；
2. 主存：高速缓存，主存，磁盘缓存；
3. 辅存：磁盘，可移动介质；



## 程序处理
编译->链接->装入



## 链接方式
- `SL<静态链接>`：事先进行链接，以后不再拆开；
- `LDL<装入时动态链接>`：装入过程中去链接所需要的模块；
- `DRL<动态运行时装入>`：运行的过程中查找和装入模块，有利于节省内存空间；



## 装入方式
- `ALM<绝对装入>`：按照指定的绝对地址装入程序；
- `RLM<可重定位转入>`：在装入时对地址指令进行修改，装入后不再修改，又叫做静态重定位；
- `DRL<动态运行时装入>`：运行时再修改地址；



## 连续分配方式
### 1.单一连续分配
只能用于单用户，单任务的OS，分为系统区和用户区；

### 2.固定分区分配
将内存中的用户空间分为固定大小的若干分区，每个分区装入一道作业；
分区方法:
1. 大小相等的分区；
2. 大小不相等的分区；

内存分配： 
将分区按大小排队，并建立一张分区使用表（例）: 

|分区号|大小(KB)|起始地址(KB)|状态|
|:--|:--|:--|:--|
|1|12|20|已分配|
|2|32|32|未分配|

### 3.动态分区分配
分区分配的数据结构：
1. 空闲分区表；
2. 空闲分区链：位于分区的起始部分，包含一个前指针和后指针，如： `|{前指针，N+2，状态位}|数据区|{后指针，N+2，状态位}|`



## 分区分配算法
**顺序搜索法**  
- `FF<首次适应算法>`：在链表中从头开始找，找到为止；
- `NF<循环首次适应算法>`：从上一次找到的位置开始找，找到合适的为止，到了链尾还没有找到的话，再从链头开始找；
- `BF<最佳适应算法>`：将空间从小到大排列，从头开始找，每次找到的都是最接近要求的大小；
- `WF<最坏适应算法>`：将空间从大到小排列，从头开始找，有利于减少碎片的产生；

**分类搜索法**
- `QF<快速适应算法>`：将空闲空间按大小分类，建立一张管理索引表，每一项对应一种大小类型，每个空闲分区放一个进程；



## 分区分配操作
1. 分配内存：找到分区，如果请求的空间小于分区空间，将分区空间一块等于请求空间大小的空间分割出去；

2. 回收内存：如果回收区与（上一个或下一个）空闲区相邻，则合并回收区域相邻区；
伙伴系统； 
哈希算法（常用）； 
动态重定位分区方式：动态重定位分区方式的寻址必须依靠重定位寄存器；

3. 分页存储：
    页面大小一般为512B~8KB; 
    页号和页内地址的计算公式：

  `P=INT(A/L)`

  `d=(A)MOD(L) `

  - INT:整除； 

  - P：页号； 

  - d:页内地址； 

  - L：页面大小；

  -  A：逻辑地址空间中的地址； 

  - MOD:取余； 

  `|页号|->|页号|块号|->|物理地址|  `
  - 页表：用于从页号到物理块号的地址映射：  
  - 存储方式的进化：固定分区->动态分区->分页存储；

4. 分段存储：
    分段地址：`（段号|段内地址）`（内部结构：段号31~16位，段内地址15~0位）， 允许最多有64K个段，每段最大长度为64KB； 
    段表寄存器：用于从进程的逻辑地知道物理地址的变换；



## 注意点
- 控制寄存器->段->页表->主存；

- `重入代码<pure code>`：不允许任何进程对它进行修改，可以配置局部数据区，通过对数据区的修改来完成对pure code的修改；

- 虚拟存储器三大特征：

  1. 多次性：一个作业分的多次调入；

  2. 对换性：运行中将不用的内容调出；

  3. 虚拟性：突破实际大小限制；

- 内存分配步骤：

  1. 最小物理块数确定。

  2. 物理块的分配方法。

  3. 物理块分配算法。

- 置换算法：

  1. 最佳置换算法。
  2. 先进先出置换。
  3. 最近最久未使用置换（LRU）。
  4. clock置换算法。
  5. 其他。

- 段表结构：`段名 + 段长 + 段基址 + 存取方式 + 访问字段A + 修改位M + 存在位P + 增补位 +外存始址`；

