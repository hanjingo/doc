# 第三章 处理机调度与死锁

[TOC]



## 3.1 处理机调度的层次和调度算法的目标

### 3.1.1 处理机调度的层次

1. 高级调度(High Level Scheduling)

   又称为长程调度或作业调度，它的调度对象是作业。根据某种算法，决定将外存上处于后备队列上的哪几个作业调入内存，为它们创建进程，分配必要的资源，并将它们放入就绪队列。

2. 低级调度(Low Level Scheduling)

   又称为进程调度或短程调度，其所调度的对象是进程（或内核级线程）。根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程。

3. 中级调度(Intermediate Scheduling)

   又称为内存调度，用于提高内存利用率和系统吞吐量。把外存上已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。

### 3.1.2 处理机调度算法的目标

1. 处理机调度算法的共同目标

   - `资源利用率`

     资源利用率计算公式：

     $CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$

   - 公平性

   - 平衡性

   - 策略强制执行

2. 批处理系统的目标

   - 平均周转时间短

     平均周转时间：

     $T=\frac{1}{n}[\sum_{i=1}^{n} T_i]$

     平均带权周转时间：

     $W = \frac{1}{n} \sum_{i=1}^{n} \frac{T_i}{T_s}$

   - 系统吞吐量高

   - 处理机利用率高

3. 分时系统的目标

   - 响应时间快
   - 均衡性

4. 实时系统的目标

   - 截止时间的保证
   - 可预测性



## 3.2 作业与作业调度

### 3.2.1 批处理系统中的作业

1. 作业(Job)和作业步(Job Step)
2. 作业控制块(Job Control Block, JCB)
3. 作业运行的三个阶段和三种状态
   - 收容阶段
   - 运行阶段
   - 完成阶段

### 3.2.2 作业调度的主要任务

在每次执行作业调度（Admission Scheduling，接纳调度）时，需要做以下决定：

1. 接纳多少个作业
2. 接纳哪些作业

### 3.2.3 先来先服务(FCFS)和短作业优先(SJF)调度算法

1. 先来先服务(first-come first-served, FCFS)调度算法

2. 短作业优先(short job first, SJF)的调度算法

   缺点：

   - 必须预知作业的运行时间。
   - 对长作业非常不利，长作业的周转时间会明显地增长。
   - 在采用FCFS算法时，人-机无法实现交互。
   - 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理。

### 3.2.4 优先级调度算法和高响应比优先调度算法

1. 优先级调度算法(priority-scheduling algorithm, PSA)

2. 高响应比优先调度算法(Highest Response Ratio Next, HRRN)

   优先级变化规律：

   $优先权 = \frac{等待时间+要求服务时间}{要求服务时间}$

   由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比$R_p$；优先又可表示为：

   $R_p = \frac{等待时间+要求服务时间}{要求服务时间} = \frac{响应时间}{要求服务时间}$



## 3.3 进程调度

### 3.3.1 进程调度的任务，机制和方式

1. 进程调度的任务

   - 保存处理机的现场信息；
   - 按某种算法选取进程；
   - 把处理器分配给进程。

2. 进程调度机制

   - 排队器

     每当有一个进程转变为就绪状态时，排队器便将它插入到相应的就绪队列。

     ![3_1](res/3_1.png)

     *进程调度机制*

   - 分派器

     依据进程调度程序所选的进程，将其从就绪队列中取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。

   - 上下文切换器

     在对处理机进行切换时，会发生2对上下文切换操作：

     1. 保存当前进程的上下文；
     2. 移出分派程序的上下文。

3. 进程调度方式

   - 非抢占方式(Nonpreemptive Mode)

     一旦把处理机分配给某进程后，就一直让它运行下去，不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机，直至该进程完成。

     引起进程调度的原因：

     1. 正在执行的进程运行完毕，或因发生某事件而使其无法再继续运行；
     2. 正在执行中的进程因提出I/O请求而暂停执行；
     3. 在进程通信或同步过程中，执行了某种原语操作。
   
   - 抢占方式(Preemptive Mode)
   
     允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一个进程。
   
     抢占的主要原则：
     
     1. `优先权原则` 指允许优先级高的新到进程抢占当前进程的处理机，即当有新进程到达时，如果它的优先级比正在执行进程的优先级高，则调度程序将剥夺当前进程的运行，将处理机分配给新到的优先权高的进程。
     2. `短进程优先原则` 指允许新到的短进程可以抢占当前长进程的处理机，即当新到达的进程比正在执行的进程明显短时，将处理机分配给新到的短进程。
     3. `时间片原则` 即各进程按时间片轮运行时，当正在执行的进程的一个时间片用完后，便停止该进程的执行而重新进行调度。

### 3.3.2 轮转调度算法

1. 轮转法(RR)的基本原理

   将所有的就绪进程按FCFS策略排成一个就绪队列。设置每隔一定时间产生一次中断，去激活进程调度程序进程调度，把CPU分配给队首进程，并令其执行一个时间片。当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片。保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间。

2. 进程切换时机

   - 若一个时间片尚未用完，正在运行的进程便已经完成；
   - 在一个时间片用完时，计时器中断处理程序被激活。

3. 时间片大小的确定

   ![3_2](res/3_2.png)

   *时间片大小对响应时间的影响*

   ![3_3](res/3_3.png)

   *q=1和q=4时进程的周转时间*

### 3.3.3 优先级调度算法

1. 优先级调度算法的类型

   - 非抢占式优先级调度算法

     把处理机分配给就绪队列中优先级最高的进程后，该进程一直执行下去直至完成。

   - 抢占式优先级调度算法

     把处理机分配给就绪队列中优先级最高的进程，如果出现另一个优先级更高的进程，调度程序就将处理机分配给新到的优先级最高的进程。

2. 优先级的类型

   - 静态优先级

     创建进程时确定，在整个运行期间保持不变；决定进程优先级大小的依据：

     - 进程类型；
     - 进程对资源的需求；
     - 用户要求。

   - 动态优先级
   
     创建进程之初，赋予一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能.

### 3.3.4 多队列调度算法

多队列调度算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。

### 3.3.5 多级反馈队列(multileved feedback queue)调度算法

1. 调度机制

   1. 设置多个就绪队列。按照优先级依次降低的顺序给每个队列赋值。

      ![3_4](res/3_4.png)

      *多级反馈队列调度算法*

   2. 每个队列都采用FCFS算法

      当新进程进入内存后，首先放入第一队列的末尾，按FCFS原则等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统；如果在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度；以此类推。

   3. 按队列优先级调度

      仅当第`1~(i-1)`所有队列均空时，才会调度第i队列中的进程。如果处理机正在第i队列中为某进程服务时又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处理机分配给新到的高优先级进程。

2. 调度算法的性能

   - 终端型用户：由于终端型用户提交的作业多属于交互型作业，通常较小；只要能使这些作业在第一队列规定的时间片内完成即可。
   - 短批处理作业用户：周转时间短。
   - 长批处理作业用户：依次在第1，2，..., n个队列中运行，不会出现作业长期得不到处理的问题。

### 3.3.6 基于公平原则的调度算法

1. 保证调度算法

   在实施公平调度算法时系统中必须具有这样一些功能：

   - 跟踪计算每个进程自创建以来已经执行的处理时间。
   - 计算每个进程应获得的处理机时间，即自创建以来的时间除以n。
   - 计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比。
   - 比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5，而进程B的比率为0.8，进程C的比率为1.2等。
   - 调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。

2. 公平分享调度算法

   使所有用户能获得相同的处理机时间，或所要求的时间比例。



## 3.4 实时调度

### 3.4.1 实现实时调度的基本条件

1. 提供必要的信息

   为了实现实时调度，系统应向调度程序提供有关任务的信息：

   - 就绪时间
   - 开始截止时间和完成截止时间
   - 处理时间
   - 资源要求
   - 优先级

2. 系统处理能力强

   在实时系统中，必须满足下面的限制条件系统才是可调度的：

   $\sum _{i=1}^{m} \frac {C_i}{P_i} \leq N$

   - $m$ 周期性硬实时任务个数
   - $C_i$ 处理时间
   - $P_i$ 周期时间

3. 采用抢占式调度机制

4. 具有快速切换机制

   该机制应具有如下两方面的能力：

   - 对中断的快速响应能力
   - 快速的任务分派能力

### 3.4.2 实时调度算法的分类

1. 非抢占式调度算法

   - 非抢占式轮转调度算法
   - 非抢占式优先调度算法

2. 抢占式调度算法

   - 基于时钟中断的抢占式优先级调度算法

     在实时任务到达后，如果其优先级高于当前任务优先级，不立即抢占当前人物的处理机，而是等时钟中断发生时，调度程序才剥夺当前人物的执行，将处理机分配给新到的高优先级任务。

   - 立即抢占(Immediate Preemption)的优先级调度算法

     一旦出现外部中断，只要当前任务未处于临界区，便能立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。
   
     ![3_5](res/3_5.png)
     
     *实时进度调度*

### 3.4.3 最早截止时间优先EDF(Earliest Deadline First)算法

1. 非抢占式调度方式用于非周期实时任务

   ![3_6](res/3_6.png)

   *EDF算法用于非抢占调度方式*

2. 抢占式调度方式用于周期实时任务

   ![3_7](res/3_7.png)

   *最早截止时间优先算法用于抢占调度方式之例*

### 3.4.4 最低松弛度优先LLF(Least Laxity First)算法

根据任务的紧急（或松弛）程度，确定任务的优先级。

![3_8](res/3_8.png)

*A和B任务每次必须完成的时间*

![3_9](res/3_9.png)

*利用ELLF算法进行调度的情况*

### 3.4.5 优先级倒置(priority inversion problem)

1. 优先级倒置的形成

   ![3_10](res/3_10.png)

   *优先级倒置示意图*

   优先级：$P_1 > P_2 > P_3$

2. 优先级倒置的解决办法

   ![3_11](res/3_11.png)

   *采用了动态优先级继承方法的运行情况*



## 3.5 死锁概述

### 3.5.1 资源问题

1. 可重用性资源和消耗性资源

   - 可重用性资源

     可重用性资源是一种可供用户重复使用多次的资源，具有如下性质：

     - 每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。
     - 进程在使用可重用性资源时，须按照以下顺序：请求资源->使用资源->释放资源。
     - 系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它。

   - 可消耗性资源

     可消耗性资源是在进程运行期间，由进程动态创建和消耗的，具有如下性质：

     - 每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的。
     - 进程在运行过程中可以不断地创造可消耗性资源的单元。
     - 进程在运行过程中可以请求多个可消耗性资源用于消耗。

2. 可抢占性资源和不可抢占性资源

   - `可抢占性资源` 进程在获得这类资源后，该资源可以再被其它进程或系统抢占。
   - `不可抢占性资源` 系统一旦把资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。

### 3.5.2 计算机系统中的死锁

1. 竞争不可抢占性资源引起死锁

   ![3_12](res/3_12.png)

   *共享文件时的死锁情况*

2. 竞争可消耗资源引起死锁

   ![3_13](res/3_13.png)

   *进程之间通信时的死锁*

3. 进程推进顺序不当引起死锁

   ![3_14](res/3_14.png)

   *进程推进顺序对死锁的影响*

   - $D$ 不安全区
   - $P_1, P_2$ 进程
   
   1. 进程推进顺序合法
   
      再进程$P_1$和$P_2$并发执行时，如果按照上图中曲线1，2，3所示的顺序推进，两进程可以顺利完成。

   2. 进程推进顺序非法
   
      当$P_1$运行到$P_1$:$Request(R_2)$时，将因$R_2$已被$P_2$占用而阻塞；当$P_2$运行到$P_2$:$Request(R_1)$时，也将因$R_1$已被$P_1$占用而阻塞，于是发生了进程死锁；

### 3.5.3 死锁的定义，必要条件和处理方法

1. 死锁的定义

   如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的(Deadlock)。

2. 产生死锁的必要条件

   - 互斥条件
   - 请求和保持条件
   - 不可抢占条件
   - 循环等待条件
   
3. 处理死锁的方法

   - 预防死锁：通过设置限制条件，去破坏产生思索地4个必要条件来预防产生死锁。
   - 避免死锁：再资源的动态分配过程中，用某种方法防止系统进入不安全转台，避免发生死锁。
   - 检测死锁：允许进程在运行过程中发生死锁，但可通过检测机构及时地检测出思索地发生，采取适当的错误，把进程从死锁中解脱出来。
   - 解除死锁：当检测到系统中已发生死锁时，采取相应措施（如：撤销进程），将进程从死锁状态中解脱出来。



## 3.6 预防死锁

### 3.6.1 破坏“请求和保持”条件

为了能破坏“请求和保持”条件，系统必须保证做到：当一个进程在请求资源时，它不能持有不可抢占资源，可通过以下协议实现：

1. 第一种协议

   所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源；

   缺点：

   - 资源被严重浪费
   - 使进程经常发生饥饿现象

2. 第二种协议

   允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中逐步释放已分配给自己的且已用毕的全部资源，然后再请求新的所需资源。

### 3.6.2 破坏“不可抢占”条件

当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。

### 3.6.3 破坏“循环等待”条件

规定每个进程必须按序号递增的顺序请求资源。一个进程在开始时，可以请求某类资源$R_i$的单元。以后，当且仅当$F(R_j) > F(R_i)$时，进程才可以请求资源$R_j$的单元。



## 3.7 避免死锁

### 3.7.1 系统安全状态

1. 安全状态

   系统能按某种进程推进顺序$(P_1, P_2, ..., P_n)$为每个进程$P_i$分配其所需资源，直至满足每个进程对资源的最大需求。

2. 安全状态之例

3. 由安全状态向不安全状态的转换

### 3.7.2 利用银行家算法避免死锁

当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给进程。

1. 银行家算法中的数据结构

   - 可利用资源向量(Available)
   - 最大需求矩阵(Max)
   - 分配矩阵(Allocation)
   - 需求矩阵(Need)

   上述矩阵间存在下述关系：

   $Need[i, j] = Max[i, j] - Allocation[i, j]$

2. 银行家算法

   设$Request_i$是进程$P_i$的请求向量，如果$Request_i[j] = K$，表示进程$P_i$需要$K$个$R_j$类型的资源。当$P_i$发出资源请求后，系统按下述步骤进行检查：

   1. 如果$Request_i[j] \leqslant Need[i, j]$，便转向步骤2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。

   2. 如果$Request_i[j] \leqslant Available[j]$，便转向步骤3；否则，表示尚无足够资源，$P_i$须等待。

   3. 系统试探着把资源分配给进程$P_i$，并修改下面数据结构中的数值：

      $Available[j] = Available[j] - Request_i[j];$

      $Allocation[i, j] = Allocation[i, j] + Request_i[j];$

      $Need[i, j] = Need[i, j] - Request_i[j];$

   4. 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程$P_i$，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程$P_i$等待。

3. 安全性算法

   系统所执行的安全性算法可描述如下：

   1. 设置两个向量

      - `工作向量Work` 表示系统可提供给进程继续运行所需的各类资源数目；
      - `Finish` 表示系统是否有足够的资源分配给进程，使之运行完成。

   2. 从进程集合中找到一个能满足下述条件的进程：

      $Finish[i] = false;$

      $Need[i, j] \leqslant Work[j];$

      若找到，执行步骤3；否则，执行步骤4。

   3. 当进程$P_i$获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：

      $Work[j] = Work[j] + Allocation[i, j];$

      $Finish[i] = true;$

      $go to step 2;$

   4. 如果所有进程的$Finish[i] = true$都满足，则表示系统处于安全状态；佛祖额，系统处于不安全状态。

4. 银行家算法示例

   略



## 3.8 死锁的检测与解除

### 3.8.1 死锁的检测

1. 资源分配图(Resource Allocation Graph)

   系统死锁，可利用资源分配图来描述。该图是由一组结点$N$和一组边$E$所组成的一对偶$G=(N,E)$，它具有下述形式的定义和限制：

   1. 把$N$分为两个互斥的子集，即一组进程结点$P={P_1, P_2, ..., P_n}$和一组资源结点$R={R_1, R_2, ..., R_n}, N = P \cup R$。
   2. 凡属于$E$中的一个边$e \in E$，都连接着$P$中的一个结点和$R$中的一个结点，$e={P_i, R_j}$是资源请求边，由进程$P_i$指向资源$R_j$，它标识进程$P_i$请求一个单位的$R_j$资源。$E = {R_j, P_i}$是资源分配边，由资源$R_j$指向进程$P_i$，它表示把一个单位的资源$R_j$分配给进程$P_i$。

   ![3_19](res/3_19.png)

   *每类资源有多个时的情况*

2. 死锁定理

   ![3_20](res/3_20.png)

   *资源分配图的简化*

   1. 在资源分配途中，找出一个既不阻塞又非独立地进程节点$P_i$。在顺利的情况下，$P_i$可获得所需资源而继续运行，直至运行完毕，再释放其所占有地全部资源，这相当于消去$P_i$的请求边和分配边，使之成为孤立的节点；如图b。
   2. $P_1$释放资源后，便可使$P_2$获得资源而继续运行，直至$P_2$完成后又释放出它所占有的全部资源，形成图c所示的情况，即将$P_2$的两条请求边和一条分配边消去。
   3. 进行一系列的简化后，若能消去图中所有的边，使所有的进程节点都成为孤立节点，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简化的。

3. 死锁检测中的数据结构

   - 可利用资源向量Available，它表示$m$类资源中每一类资源的可用数目。
   - 把不占用资源的进程（向量Allocation=0）记入L表中，即$L_i \cup L$。
   - 从进程集合中找到一个$Request_i \leqslant Work$的进程，做如下处理：
     1. 将其资源分配图简化，释放出资源，增加工作向量$Work = Work + Allocation_i$；
     2. 将它记入$L$表中。
   - 若不能把所有进程都记入$L$表中，便表明系统状态$S$的资源分配图是不可完全简化的。因此，该系统状态将发生死锁。

### 3.8.2 死锁的解除

常用的解除死锁的方法：

- 抢占资源
- 终止（或撤销）进程

1. 终止进程的方法

   - 终止所有死锁进程
   - 逐个终止进程

2. 付出代价最小的死锁解除算法

   ![3_21](res/3_21.png)

   *付出代价最小的的死锁解除算法*

   所花费的代价：$R(S)_{min} = min{C_{ui}} + min{C_{uj}} + min{C_{uk}} + ...$

   

   