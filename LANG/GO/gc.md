# go的GC



## 摘要



## 垃圾回收的常见方法

| 方法                         | 原理                                                         | 优点                                              | 缺点                                                         |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------- | ------------------------------------------------------------ |
| 引用计数(reference counting) | 引用计数通过在对象上增加自己被引用的次数，被其他对象引用时加1，引用自己的对象被回收时减1，引用数为0的对象即为可以被回收的对象。 | - 方式简单，回收速度快                            | - 需要额外的空间存放计数<br>- 无法处理循环引用（如a.b=b;b.a=a这种情况）。<br>- 频繁更新引用计数降低了性能 |
| 标记-清除(mark and sweep)    | 标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作） | - 解决了“引用计数”的缺点                          | - 每次启动垃圾回收都会暂停当前所有的正常代码执行             |
| 复制收集                     | 准备一个「新的空间」，从根开始，对对象进行扫，如果存在对这个对象的引用，就把它复制到「新空间中」。一次扫描结束之后，所有存在于「新空间」的对象就是所有的非垃圾对象。 | - 对于垃圾比例较小的情况，相比“标记-清除”更占优势 | -                                                            |
| 分代收集(generation)         | 根据对象的存活周期不同将内存划分为新生代和老年代，存活周期短的为新生代，存活周期长的为老年代。高频对新生成的对象进行回收，称为「小回收」;低频对所有对象回收，称为「大回收」;每一次「小回收」过后，就把存活下来的对象归为老年代，「小回收」的时候，遇到老年代直接跳过。 |                                                   |                                                              |



## 三色标记法

go使用的垃圾回收方法是：**三色标记法**，属于“标记-清除(mark and sweep)”的一种。（小道消息说go以后会改成：混合写屏障法，hybrid write barrier）

### 原理

1. 将所有内存对象分为3种颜色
   - 白色
   - 灰色
   - 黑色
2. 一开始所有的对象都是白色（悲观）
3. 从根出发扫描所有可达对象，标记为灰色，放入待处理队列
4. 从待处理队列中取出灰色对象，将其**引用对象**标记为灰色放入队列，将其**自身**标记为黑色
5. 重复步骤4，直到灰色对象队列为空。此时所有的**白色对象**为**垃圾**，进行回收
6. 重置



## GC调优

1. `GOGC`参数主要用来控制**下一次gc开始的时候的内存使用量**，通过调大这个数可以延迟gc的到来



## 参考

- [Golang GC 垃圾回收机制详解](https://blog.csdn.net/u010649766/article/details/80582153)