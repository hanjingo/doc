# 第三章 容器适配器
## 摘要
容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能

## 详情
### 容器适配器类别
* stack<T>是一个封装了deque<T>容器的适配器类模板，默认实现的是一个后入先出(LIFO)的压入栈
* queue<T>是一个封装了deque<T>容器的适配器类模板，默认实现的是一个先入先出(FIFO)的队列
* priority_queue<T>是一个封装了vector<T>容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列

### 栈(stack)
* top()：返回一个栈顶元素的引用，类型为T&。如果栈为空，返回值未定义
* push(const T& obj)：将对象副本压入栈顶
* push(T&& obj)：以移动对象的方式将对象压入栈顶
* pop()：弹出栈顶元素
* empty()：在栈中没有元素的情况下返回true
* emplace()：用传入的参数调用构造函数，在栈顶生成对象
* swap(stack<T>& other_stack)将当前栈中的元素和参数中的元素交换

### 队列(queue)
* front()：返回queue中第一个元素的引用
* back()：返回queue中最后一个元素的引用
* push(const T& obj)：在queue的尾部添加一个元素的副本
* push(T&& obj)：以移动的方式在queue的尾部添加元素
* pop()：删除queue中的第一个元素
* size()：返回queue中元素的个数
* empty()：返回true，如果queue中没有元素的话
* emplace()：用传给emplace()的参数调用T的构造函数，在queue的尾部生成对象
* swap(queue<T>&other_q)：将当前queue中的元素和参数queue中的元素交换

### 优先队列(priority_queue)
* push(const T& obj)：将obj的副本放到容器的适当位置，这通常会包含一个排序操作
* push(T&& obj)：将obj放到容器的适当位置，这通常会包含一个排序操作
* emplace(T constructor args..)：通过调用传入参数的构造函数，在序列的适当位置构造一个T对象
* top()：返回优先级队列中第一个元素的引用
* pop()：移除第一个元素
* size()：返回队列中元素的个数
* empty()：返回true，如果队列为空的话
* swap(priority_queue<T>& other)：和参数的元素进行交换，所包含对象的类型必须相同

### 堆(heap)
#### 在容器中保存指针
大多数时候，保存只能指针比原生指针好；原因：
> 在容器中保存指针需要复制指针而不是它指向的对象；  
> 在容器中保存指针可以得到多态性；  
> 对指针容器的内容进行排序的速度要比对对象排序快；  
> 保存智能指针要比保存原生指针安全，因为在对象不再被引用时，自由存储区的对象会被自动删除；  

## 总结
* stack<T>容器适配器模板实现了一个压入栈
* queue<T>容器适配器模板实现了一个队列
* priority_queue<T>容器适配器模板实现了一个优先级队列
* 堆是一个二叉树，他的部分节点和全部节点有相同的顺序。对于大顶堆，父节点会大于等于他的子节点；对于小顶堆，父节点会小于定义它的子节点
* make_heap()函数模板可以在随机访问迭代器指定的范围内创建一个元素堆。默认创建大顶堆；
* 可以在容器中保存指针
* 对于保存指针的容器来说，我们需要为他们提供一些算法需要的函数对象，这些函数通常用来进行比较或进行其他的一些运算