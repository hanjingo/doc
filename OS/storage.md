# 存储器

[TOC]

## 分层

1. cpu
   - 寄存器
2. 主存
   - 高速缓存
   - 主存
   - 磁盘缓存
3. 辅存
   - 磁盘
   - 可移动介质

### 存储数据查找过程

控制寄存器->段->页表->主存



## 分区分配

### 内存分配步骤

1. 确定最小物理块数
2. 确定物理块的分配方式
3. 确定物理块分配算法

### 分配方式

1. 单一连续分配

   只能用于单用户，单任务的OS，分为系统区和用户区；

2. 固定分配

   将内存中的用户空间分为固定大小的若干分区，每个分区装入一道作业；

   分区算法：

   1. 大小相等的分区；
   2. 大小不相等的分区；

   例，将分区按大小排队，并建立一张分区使用表：

   | 分区号 | 大小(KB) | 起始地址(KB) | 状态   |
   | ------ | -------- | ------------ | ------ |
   | 1      | 12       | 20           | 已分配 |
   | 2      | 32       | 32           | 未分配 |

3. 动态分区分配

   分区分配的数据结构：

   1. 空闲分区表

   2. 空闲分区链

      位于分区的起始部分，包含一个前指针和后指针。

      结构如图：`{前指针，N+2，状态位}+数据区+{后指针，N+2，状态位}`

### 分配算法

**顺序搜索法**

- `FF<首次适应算法>`：在链表中从头开始找，找到为止；
- `NF<循环首次适应算法>`：从上一次找到的位置开始找，找到合适的为止，到了链尾还没有找到的话，再从链头开始找；
- `BF<最佳适应算法>`：将空间从小到大排列，从头开始找，每次找到的都是最接近要求的大小；
- `WF<最坏适应算法>`：将空间从大到小排列，从头开始找，有利于减少碎片的产生；

**分类搜索法**

- `QF<快速适应算法>`：将空闲空间按大小分类，建立一张管理索引表，每一项对应一种大小类型，每个空闲分区放一个进程；



## 分配操作

1. 分配内存

   找到分区，如果请求的空间小于分区空间，将分区空间一块等于请求空间大小的空间分割出去；

2. 回收内存

   如果回收区与（上一个或下一个）空闲区相邻，则合并回收区域相邻区；

3. 分页存储

   页面大小一般为512B~8KB

   寻址方式：`页号->块号->物理地址`

   页号和页内地址的计算公式：`P=INT(A/L)`，  `d=(A)MOD(L)`

   - INT:整除
   - P:页号
   - d:页内地址
   - L:页面大小
   - A:逻辑地址空间中的地址
   - MOD:取余

4. 分段存储

   - 分段地址

     `（段号|段内地址）`，段号31~16位，段内地址15~0位

     允许最多有64K个段，每段最大长度为64KB；

   - 段表寄存器

     用于从进程的逻辑地知道物理地址的变换；



## 置换算法

### 最佳置换

### 先进先出置换

### 最近最久未使用置换(LRU)

### clock置换

### 其他

