# Redis源码分析-压缩列表


<!-- vim-markdown-toc GFM -->

* [压缩列表的构成](#压缩列表的构成)
* [压缩列表节点的构成](#压缩列表节点的构成)
* [连锁更新](#连锁更新)
    - [时间复杂度](#时间复杂度)
* [压缩列表API](#压缩列表api)
* [参考](#参考)

<!-- vim-markdown-toc -->



压缩列表（ziplist）是列表键和哈希键的底层实现之一，当一个列表键只包含少量列表项，并且每个列表要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现；

例，执行以下命令将创建一个压缩列表实现的列表键：

```sh
redis> RPUSH lst 1 3 5 10086 "hello" "world"
redis> OBJECT ENCODING lst
```



## 压缩列表的构成

压缩列表的组成部分：

`|zlbytes|zltail|zllen|entry1|entry2|...|entryN|zlend|`

| 属性    | 类型     | 长度(字节) | 用途                                                         |
| ------- | -------- | ---------- | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4          | 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算zlend的位置时使用 |
| zltail  | uint32_t | 4          | 记录压缩列表表尾节点距离列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址 |
| zllen   | uint16_t | 2          | 记录了压缩列表包含的节点数量：当这个属性的值小于UINT16_MAX（65535）时，这个属性的值就是压缩列表包含节点的数量；当这个值等于UINT16_MAX时，节点的真实数量需要遍历整个压缩列表才能计算得出 |
| entryX  | 列表节点 | 不定       | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定       |
| zlend   | uint8_t  | 1          | 特殊值0xFF（十进制255），用于标记压缩列表的末端              |

例，包含三个节点的压缩列表：

| zlbytes | zltail | zllen | entry1 | entry2 | entry3 | zlend |
| ------- | ------ | ----- | ------ | ------ | ------ | ----- |
| 0x50    | 0x3c   | 0x3   |        |        |        | 0xFF  |

- `zlbytes` 0x50(十进制80)，表示压缩列表的总长度为80字节；
- `zltail` 0x3c(十进制60)，表示如果有一个指向压缩列表起始地址的指针p，那么只要用p加上偏移量60，就可以计算出表尾节点entry3的地址；
- `zllen` 0x3(十进制3)，表示压缩列表包含3个节点；



## 压缩列表节点的构成

每个压缩列表节点由以下部分组成：

| previous_entry_length | encoding | content |
| --------------------- | -------- | ------- |
| 1~5字节               |          |         |

- previous_entry_length

  以字节为单位，记录了压缩列表中前一个节点的长度；根据前一个节点长度不同，属性的长度也有区别：

  - 前一节点的长度小于254字节：长度1字节；
  - 前一节点的长度大于等于254字节：长度5字节，第一个字节为`0x05`，后4个字节保存前一节点长度；

- encoding

  记录了节点的content属性所保存数据的类型以及长度；

  字节数组编码：

  | 编码                                              | 编码长度(字节) | content属性保存的值              |
  | ------------------------------------------------- | -------------- | -------------------------------- |
  | 00bbbbbb                                          | 1              | 长度小于等于63字节的字节数组     |
  | 01bbbbbb xxxxxxxx                                 | 2              | 长度小于等于16383字节的字节数组  |
  | 10_ _ _ _ _ _ aaaaaaaa bbbbbbbb cccccccc dddddddd | 5              | 长度小于等于4294967295的字节数组 |

  - `_` 表示留空
  - b, x 代表实际二进制数据

  整数编码：

  | 编码     | 编码长度(字节) | content属性保存的值                                          |
  | -------- | -------------- | ------------------------------------------------------------ |
  | 11000000 | 1              | int16_t类型的整数                                            |
  | 11010000 | 1              | int32_t类型的整数                                            |
  | 11100000 | 1              | int64_t类型的整数                                            |
  | 11110000 | 1              | 24位有符号整数                                               |
  | 11111110 | 1              | 8位有符号整数                                                |
  | 1111xxxx | 1              | 使用这一编码的节点没有相应的content属性，因为编码本身的xxxx四个位已经保存了一个介于0和12之间的值，所以它无须content属性 |

- content

  负责保存节点的值，节点值可以是一个字节数组或整数，值的类型和长度由节点的encoding属性决定；

例，保存字节数组“hello world”的节点：

| previous_entry_length | encoding | content       |
| --------------------- | -------- | ------------- |
| ...                   | 00001011 | "hello world" |



## 连锁更新

如果在一个压缩列表中，有多个连续的，长度小于254字节的节点，当向其中插入一个长度大于等于254字节的新节点；由于旧节点的`previous_entry_length`属性仅长1字节，无法保存新节点的长度，程序将对压缩列表执行空间重新分配操作，Redis将这种特殊情况下产生的连续多次空间扩展操作称为“连锁更新”（cascade update）；

添加或删除节点都可能会引发连锁更新；例：

`|zlbytes|zltail|zllen|e1|e2|e3|...|eN|zlend|`

添加新节点到压缩列表

`|zlbytes|zltail|zllen|new|e1|e2|e3|...|eN|zlend|`

扩展e1, e2, e3, ..., eN

### 时间复杂度

连锁更行在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为$O(N)$，所以连锁更新的最坏复杂度为$O(N^2)$；

尽管连锁更新的复杂度较高，但它真正造成性能问题的几率很低，原因如下：

- 压缩列表里要恰好有多个连续的，长度介于250字节至253字节之间的节点，连锁更新才有可能被引发；
- 即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响；



## 压缩列表API

| 函数               | 作用                                                         | 算法复杂度                                                   |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ziplistNew         | 创建一个新的压缩列表                                         | $O(1)$                                                       |
| ziplistPush        | 创建一个包含给定值的新节点，并将这个新节点添加到压缩列表的表头或者表尾 | 平均$O(N)$，最坏$O(N^2)$                                     |
| ziplistInsert      | 将包含给定值的新节点插入到给定节点之后                       | 平均$O(N)$，最坏$O(N^2)$                                     |
| ziplistIndex       | 返回压缩列表给定索引上的节点                                 | $O(N)$                                                       |
| ziplistFind        | 在压缩列表中查找并返回包含了给定值的节点                     | 因为节点的值可能是一个字节数组，所以检查节点值和给定值是否相同的复杂度为$O(N)$，而查找整个列表的复杂度则为$O(N^2)$； |
| ziplistNext        | 返回给定节点的下一个节点                                     | $O(1)$                                                       |
| ziplistPrev        | 返回给定节点的前一个节点                                     | $O(1)$                                                       |
| ziplistGet         | 获取给定节点所保存的值                                       | $O(1)$                                                       |
| ziplistDelete      | 从压缩列表中删除给定的节点                                   | 平均$O(N)$，最坏$O(N^2)$                                     |
| ziplistDeleteRange | 删除压缩列表在给定索引上的连续多个节点                       | 平均$O(N)$，最坏$O(N^2)$                                     |
| ziplistBlobLen     | 返回压缩列表目前占用的内存字节数                             | $O(1)$                                                       |
| ziplistLen         | 返回压缩列表目前包含的节点数量                               | 节点数量小于65535时为$O(1)$，大于65535时为$O(N)$             |

**ziplistPush, ziplistInsert, ziplistDelete和ziplistDeleteRange四个函数都有可能引发连锁更新；**



## 参考

[1] 黄健宏.Redis设计与实现
